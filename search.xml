<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[栈]]></title>
      <url>/2018/10/08/%E6%A0%88/</url>
      <content type="html"><![CDATA[<p>后进者先出，先进者后出，这就是典型的“栈”结构。</p>
<a id="more"></a>
<p>从栈的操作特性上来看，栈是一种“操作受限”的线性表，只允许在一端插入和删除数据。当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，我们就应该首选“栈”这种数据结构。</p>
<h3 id="实现一个“栈”"><a href="#实现一个“栈”" class="headerlink" title="实现一个“栈”"></a>实现一个“栈”</h3><p>栈既可以用数组来实现，也可以用链表来实现。用数组实现的栈，我们叫作顺序栈，用链表实现的栈，我们叫作链式栈。以下代码是一个基于数组来实现的顺序栈。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 基于数组实现的顺序栈</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> String[] items;  <span class="comment">// 数组</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">int</span> count;       <span class="comment">// 栈中元素个数</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">int</span> n;           <span class="comment">// 栈的大小</span></div><div class="line"></div><div class="line">  <span class="comment">// 初始化数组，申请一个大小为 n 的数组空间</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.items = <span class="keyword">new</span> String[n];</div><div class="line">    <span class="keyword">this</span>.n = n;</div><div class="line">    <span class="keyword">this</span>.count = <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 入栈操作</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">push</span><span class="params">(String item)</span> </span>&#123;</div><div class="line">    <span class="comment">// 数组空间不够了，直接返回 false，入栈失败。</span></div><div class="line">    <span class="keyword">if</span> (count == n) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    <span class="comment">// 将 item 放到下标为 count 的位置，并且 count 加一</span></div><div class="line">    items[count] = item;</div><div class="line">    ++count;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="comment">// 出栈操作</span></div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">pop</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 栈为空，则直接返回 null</span></div><div class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    <span class="comment">// 返回下标为 count-1 的数组元素，并且栈中元素个数 count 减一</span></div><div class="line">    String tmp = items[count-<span class="number">1</span>];</div><div class="line">    --count;</div><div class="line">    <span class="keyword">return</span> tmp;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不管是顺序栈还是链式栈，我们存储数据只需要一个大小为 n 的数组就够了。在入栈和出栈过程中，只需要一两个临时变量存储空间，所以空间复杂度是 O(1)。我们说空间复杂度的时候，是指除了原本的数据存储空间外，算法运行还需要额外的存储空间。</p>
<h3 id="动态扩容的顺序栈"><a href="#动态扩容的顺序栈" class="headerlink" title="动态扩容的顺序栈"></a>动态扩容的顺序栈</h3><p>要实现一个支持动态扩容的栈，只需要底层依赖一个支持动态扩容的数组就可以了。当栈满了之后，我们就申请一个更大的数组，将原来的数据搬移到新数组中。</p>
<p><img src="https://static001.geekbang.org/resource/image/b1/da/b193adf5db4356d8ab35a1d32142b3da.jpg" alt=""></p>
<p>对于出栈操作来说，由于不会涉及内存的重新申请和数据的搬移，所以出栈的时间复杂度仍然是 O(1)。对于入栈操作来说，当栈中有空闲空间时，入栈操作的时间复杂度为 O(1)。但当空间不够时，就需要重新申请内存和数据搬移，所以时间复杂度就变成了 O(n)。对于平均时间复杂度，我们可以用摊还分析法来分析。</p>
<p>我们先做一些假设和定义：</p>
<ul>
<li>栈空间不够时，我们重新申请一个是原来大小两倍的数组；</li>
<li>为了简化分析，假设只有入栈操作没有出栈操作；</li>
<li>定义不涉及内存搬移的入栈操作为 simple-push 操作，时间复杂度为 O(1)。</li>
</ul>
<p>如果当前栈大小为 K，并且已满，当再有新的数据要入栈时，就需要重新申请 2 倍大小的内存，并且做 K 个数据的搬移操作，然后再入栈。但是，接下来的 K-1 次入栈操作，我们都不需要再重新申请内存和搬移数据，所以这 K-1 次入栈操作都只需要一个 simple-push 操作就可以完成。</p>
<p><img src="https://static001.geekbang.org/resource/image/c9/bb/c936a39ad54a9fdf526e805dc18cf6bb.jpg" alt=""></p>
<p>这 K 次入栈操作，总共涉及了 K 个数据的搬移，以及 K 次 simple-push 操作。将 K 个数据搬移均摊到 K 次入栈操作，那每个入栈操作只需要一个数据搬移和一个 simple-push 操作。以此类推，入栈操作的均摊时间复杂度就为 O(1)。</p>
<p>这也印证了前面讲到的，均摊时间复杂度一般都等于最好情况时间复杂度。因为在大部分情况下，入栈操作的时间复杂度 O 都是 O(1)，只有在个别时刻才会退化为 O(n)，所以把耗时多的入栈操作的时间均摊到其他入栈操作上，平均情况下的耗时就接近 O(1)。</p>
<h3 id="栈在函数调用中的应用"><a href="#栈在函数调用中的应用" class="headerlink" title="栈在函数调用中的应用"></a>栈在函数调用中的应用</h3><p>栈的一个经典应用场景就是<strong>函数调用栈</strong>。</p>
<p>操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构, 用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">int</span> a = <span class="number">1</span>; </div><div class="line">   <span class="keyword">int</span> ret = <span class="number">0</span>;</div><div class="line">   <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">   ret = add(<span class="number">3</span>, <span class="number">5</span>);</div><div class="line">   res = a + ret;</div><div class="line">   printf(<span class="string">"%d"</span>, res);</div><div class="line">   reuturn <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">   <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">   sum = x + y;</div><div class="line">   <span class="keyword">return</span> sum;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码中，main() 函数调用了 add() 函数，获取计算结果，当执行到add() 函数时，其函数调用栈情况如下图：</p>
<p><img src="https://static001.geekbang.org/resource/image/17/1c/17b6c6711e8d60b61d65fb0df5559a1c.jpg" alt=""></p>
<h3 id="栈在表达式求值中的应用"><a href="#栈在表达式求值中的应用" class="headerlink" title="栈在表达式求值中的应用"></a>栈在表达式求值中的应用</h3><p>编译器利用栈来实现<strong>表达式求值</strong>就是栈的另一个常见的应用场景。</p>
<p>编译器就是通过两个栈来实现的。其中一个保存操作数的栈，另一个是保存运算符的栈。我们从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较。</p>
<p>如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取 2 个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。</p>
<p>例如3+5*8-6 这个表达式的计算过程如下图所示：</p>
<p><img src="https://static001.geekbang.org/resource/image/bc/00/bc77c8d33375750f1700eb7778551600.jpg" alt=""></p>
<h3 id="栈在括号匹配中的应用"><a href="#栈在括号匹配中的应用" class="headerlink" title="栈在括号匹配中的应用"></a>栈在括号匹配中的应用</h3><p>我们还可以借助栈来检查表达式中的括号是否匹配。</p>
<p>假设表达式中只包含三种括号，圆括号 ()、方括号 [] 和花括号{}，并且它们可以任意嵌套。比如，{[{}]}或 [{()}([])] 等都为合法格式，而{[}()] 或 [({)] 为不合法的格式。这时候就可以借助栈来检验他们的合法性。</p>
<p>我们用栈来保存未匹配的左括号，从左到右依次扫描字符串。当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号。如果能够匹配，比如“(”跟“)”匹配，“[”跟“]”匹配，“{”跟“}”匹配，则继续扫描剩下的字符串。如果扫描的过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。</p>
<p>当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法格式；否则，说明有未匹配的左括号，为非法格式。</p>
<h3 id="栈在浏览器中的应用"><a href="#栈在浏览器中的应用" class="headerlink" title="栈在浏览器中的应用"></a>栈在浏览器中的应用</h3><p>实现浏览器的前进、后退功能其实用两个栈就可以完美实现。</p>
<p>我们使用两个栈，X 和 Y，我们把首次浏览的页面依次压入栈 X，当点击后退按钮时，再依次从栈 X 中出栈，并将出栈的数据依次放入栈 Y。当我们点击前进按钮时，我们依次从栈 Y 中取出数据，放入栈 X 中。当栈 X 中没有数据时，那就说明没有页面可以继续后退浏览了。当栈 Y 中没有数据，那就说明没有页面可以点击前进按钮浏览了。</p>
<p>比如你顺序查看了 a，b，c 三个页面，我们就依次把 a，b，c 压入栈，这个时候，两个栈的数据就是这个样子：</p>
<p><img src="https://static001.geekbang.org/resource/image/4b/3d/4b579a76ea7ebfc5abae2ad6ae6a3c3d.jpg" alt=""></p>
<p>当你通过浏览器的后退按钮，从页面 c 后退到页面 a 之后，我们就依次把 c 和 b 从栈 X 中弹出，并且依次放入到栈 Y。这个时候，两个栈的数据就是这个样子：</p>
<p><img src="https://static001.geekbang.org/resource/image/b5/1b/b5e496e2e28fe08f0388958a0e12861b.jpg" alt=""></p>
<p>这个时候你又想看页面 b，于是你又点击前进按钮回到 b 页面，我们就把 b 再从栈 Y 中出栈，放入栈 X 中。此时两个栈的数据是这个样子：</p>
<p><img src="https://static001.geekbang.org/resource/image/ea/bc/ea804125bea25d25ba467a51fb98c4bc.jpg" alt=""></p>
<p>这个时候，你通过页面 b 又跳转到新的页面 d 了，页面 c 就无法再通过前进、后退按钮重复查看了，所以需要清空栈 Y。此时两个栈的数据这个样子：</p>
<p><img src="https://static001.geekbang.org/resource/image/a3/2e/a3c926fe3050d9a741f394f20430692e.jpg" alt=""></p>
<h3 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h3><p>栈是一种操作受限的数据结构，只支持入栈和出栈操作。后进先出是它最大的特点。栈既可以通过数组实现，也可以通过链表来实现。不管基于数组还是链表，入栈、出栈的时间复杂度都为 O(1)。</p>
]]></content>
      
        <categories>
            
            <category> 数据结构和算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数据结构和算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[链表]]></title>
      <url>/2018/10/07/%E9%93%BE%E8%A1%A8/</url>
      <content type="html"><![CDATA[<p>相比数组，链表是一种稍微复杂一点的数据结构。这两个非常基础、非常常用的数据结构，我们常常将会放到一块儿来比较。所以我们先来看，这两者有什么区别。</p>
<a id="more"></a>
<p>我们从底层的存储结构上来对比下。</p>
<p><img src="https://static001.geekbang.org/resource/image/d5/cd/d5d5bee4be28326ba3c28373808a62cd.jpg" alt=""></p>
<p>从图中我们看到，数组需要一块连续的内存空间来存储，对内存的要求比较高。如果我们申请一个 100MB 大小的数组，当内存中没有连续的、足够大的存储空间时，即便内存的剩余总可用空间大于 100MB，仍然会申请失败。</p>
<p>而链表恰恰相反，它并不需要一块连续的内存空间，它通过“指针”将一组零散的内存块串联起来使用，所以如果我们申请的是 100MB 大小的链表，根本不会有问题。</p>
<p>链表结构五花八门，今天我重点给你介绍三种最常见的链表结构，它们分别是：单链表、双向链表和循环链表。</p>
<h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>链表通过指针将一组零散的内存块串联在一起。其中，我们把内存块称为链表的“结点”。为了将所有的结点串起来，每个链表的结点除了存储数据之外，还需要记录链上的下一个结点的地址。如图所示，我们把这个记录下个结点地址的指针叫作<strong>后继指针 next</strong>。</p>
<p><img src="https://static001.geekbang.org/resource/image/b9/eb/b93e7ade9bb927baad1348d9a806ddeb.jpg" alt=""></p>
<p>从图中可以看到第一个结点和最后一个结点比较特殊。我们习惯性地把第一个结点叫作头结点，把最后一个结点叫作尾结点。其中，头结点用来记录链表的基地址。有了它，我们就可以遍历得到整条链表。而尾结点特殊的地方是：指针不是指向下一个结点，而是指向一个<strong>空地址 NULL</strong>，表示这是链表上最后一个结点。</p>
<p>在进行数组的插入、删除操作时，为了保持内存数据的连续性，需要做大量的数据搬移，所以时间复杂度是 O(n)。而在链表中插入或者删除一个数据，我们并不需要为了保持内存的连续性而搬移结点，因为链表的存储空间本身就不是连续的。所以，在链表中插入和删除一个数据是非常快速的。</p>
<p><img src="https://static001.geekbang.org/resource/image/45/17/452e943788bdeea462d364389bd08a17.jpg" alt=""></p>
<p>从图中我们可以看出，针对链表的插入和删除操作，我们只需要考虑相邻结点的指针改变，所以对应的时间复杂度是 O(1)。</p>
<p>但是链表要想随机访问第 k 个元素，就没有数组那么高效了。因为链表中的数据并非连续存储的，所以无法像数组那样，根据首地址和下标，通过寻址公式就能直接计算出对应的内存地址，而是需要根据指针一个结点一个结点地依次遍历，直到找到相应的结点。</p>
<p>你可以把链表想象成一个队伍，队伍中的每个人都只知道自己后面的人是谁，所以当我们希望知道排在第 k 位的人是谁的时候，就需要从第一个人开始，一个一个地往下数。所以，链表随机访问的性能没有数组好，需要 O(n) 的时间复杂度。</p>
<h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>循环链表是一种特殊的单链表。它跟单链表唯一的区别就在尾结点。循环链表的尾结点指针是指向链表的头结点。</p>
<p><img src="https://static001.geekbang.org/resource/image/86/55/86cb7dc331ea958b0a108b911f38d155.jpg" alt=""></p>
<p>从图中可以看出来，它像一个环一样首尾相连，所以叫作“循环”链表。和单链表相比，循环链表的优点是从链尾到链头比较方便。当要处理的数据具有环型结构特点时，就特别适合采用循环链表。尽管用单链表也可以实现，但是用循环链表实现的话，代码就会简洁很多。</p>
<h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>双向链表支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点。</p>
<p><img src="https://static001.geekbang.org/resource/image/cb/0b/cbc8ab20276e2f9312030c313a9ef70b.jpg" alt=""></p>
<p>从图中可以看出来，双向链表需要额外的两个空间来存储后继结点和前驱结点的地址。所以，如果存储同样多的数据，双向链表要比单链表占用更多的内存空间。虽然两个指针比较浪费存储空间，但可以支持双向遍历，这样也带来了双向链表操作的灵活性。</p>
<p>从结构上来看，双向链表可以支持 O(1) 时间复杂度的情况下找到前驱结点，正是这样的特点，也使双向链表在某些情况下的插入、删除等操作都要比单链表简单、高效。</p>
<p>在上面我们提到单链表的插入、删除操作的时间复杂度已经是 O(1) 了，双向链表还能再怎么高效呢？我们再分析链表的删除和插入操作。</p>
<p>从链表中删除一个数据无外乎这两种情况：</p>
<ul>
<li>删除结点中“值等于某个给定值”的结点；</li>
<li>删除给定指针指向的结点。</li>
</ul>
<p>对于第一种情况，不管是单链表还是双向链表，为了查找到值等于给定值的结点，都需要从头结点开始一个一个依次遍历对比，直到找到值等于给定值的结点，然后再通过我前面讲的指针操作将其删除。</p>
<p>尽管单纯的删除操作时间复杂度是 O(1)，但遍历查找的时间是主要的耗时点，对应的时间复杂度为 O(n)。根据时间复杂度分析中的加法法则，删除值等于给定值的结点对应的链表操作的总时间复杂度为 O(n)。</p>
<p>对于第二种情况，我们已经找到了要删除的结点，但是删除某个结点 q 需要知道其前驱结点，而单链表并不支持直接获取前驱结点，所以，为了找到前驱结点，我们还是要从头结点开始遍历链表，直到 p-&gt;next=q，说明 p 是 q 的前驱结点。</p>
<p>因为双向链表中的结点已经保存了前驱结点的指针，不需要像单链表那样遍历。所以，针对第二种情况，单链表删除操作需要 O(n) 的时间复杂度，而双向链表只需要在 O(1) 的时间复杂度内就搞定了！</p>
<p>同理，如果我们希望在链表的某个指定结点前面插入一个结点，双向链表比单链表有很大的优势。</p>
<p>除了插入、删除操作有优势之外，对于一个有序链表，双向链表的按值查询的效率也要比单链表高一些。因为，我们可以记录上次查找的位置 p，每次查询时，根据要查找的值与 p 的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。</p>
<p>这就是为什么在实际的软件开发中，双向链表尽管比较费内存，但还是比单链表的应用更加广泛的原因（Java 中的LinkedHashMap 的实现原理就用到了双向链表）。</p>
<p>当内存空间充足的时候，如果我们更加追求代码的执行速度，我们就可以选择空间复杂度相对较高、但时间复杂度相对很低的算法或者数据结构，采用空间换时间的设计思想。相反，如果内存比较紧缺，比如代码跑在手机或者单片机上，这个时候，就要反过来用时间换空间的设计思路。</p>
<p>如果把循环链表和双向链表整合在一起就是一个新的版本：双向循环链表，它的结构应该是这样：</p>
<p><img src="https://static001.geekbang.org/resource/image/d1/91/d1665043b283ecdf79b157cfc9e5ed91.jpg" alt=""></p>
<h3 id="链表-VS-数组性能大比拼"><a href="#链表-VS-数组性能大比拼" class="headerlink" title="链表 VS 数组性能大比拼"></a>链表 VS 数组性能大比拼</h3><p>因为内存存储的区别，链表与数组的插入、删除、随机访问操作的时间复杂度正好相反。</p>
<p><img src="https://static001.geekbang.org/resource/image/4f/68/4f63e92598ec2551069a0eef69db7168.jpg" alt=""></p>
<p>数组简单易用，在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。</p>
<p>数组的缺点是大小固定，一经声明就要占用整块连续内存空间。如果声明的数组过小，则可能出现不够用的情况。这时只能再申请一个更大的内存空间，把原数组拷贝进去，非常费时。链表本身没有大小的限制，天然地支持动态扩容，这也是它与数组最大的区别。</p>
<h3 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h3><p>链表跟数组一样，也是非常基础、非常常用的数据结构。不过链表要比数组稍微复杂，从普通的单链表衍生出来好几种链表结构，比如双向链表、循环链表、双向循环链表。</p>
<p>和数组相比，链表更适合插入、删除操作频繁的场景，不过查询的时间复杂度较高。</p>
]]></content>
      
        <categories>
            
            <category> 数据结构和算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数据结构和算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数组]]></title>
      <url>/2018/10/06/%E6%95%B0%E7%BB%84/</url>
      <content type="html"><![CDATA[<p>在每一种编程语言中，基本都有数组这种数据类型，它不仅仅是一种数据类型，还是一种最基础的数据结构。</p>
<a id="more"></a>
<p><strong>数组是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据</strong>。</p>
<p>数组的定义涉及到了几个关键词，分别是<strong>线性表</strong>、<strong>连续的内存空间和相同类型的数据</strong>。</p>
<h5 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h5><p>线性表就是数据排成像一条线一样的结构，每个线性表上的数据最多只有前和后两个方向。其实除了数组，链表、队列、栈等也是线性表结构。</p>
<p><img src="https://static001.geekbang.org/resource/image/b6/77/b6b71ec46935130dff5c4b62cf273477.jpg" alt=""></p>
<p>与它相对立的概念是非线性表，比如二叉树、堆、图等。之所以叫非线性，是因为，在非线性表中，数据之间并不是简单的前后关系。</p>
<p><img src="https://static001.geekbang.org/resource/image/6e/69/6ebf42641b5f98f912d36f6bf86f6569.jpg" alt=""></p>
<h5 id="连续的内存空间和相同类型的数据"><a href="#连续的内存空间和相同类型的数据" class="headerlink" title="连续的内存空间和相同类型的数据"></a>连续的内存空间和相同类型的数据</h5><p>正是因为这两个限制，它才有了一个堪称“杀手锏”的特性：“随机访问”。但也让数组的很多操作变得非常低效，比如要想在数组中删除、插入一个数据，为了保证连续性，就需要做大量的数据搬移工作。</p>
<h3 id="如何实现随机访问？"><a href="#如何实现随机访问？" class="headerlink" title="如何实现随机访问？"></a>如何实现随机访问？</h3><p><img src="https://static001.geekbang.org/resource/image/98/c4/98df8e702b14096e7ee4a5141260cdc4.jpg" alt=""></p>
<p>上图是一个长度为 10 的 int 类型的数组。计算机给数组 a[10]，分配了一块连续内存空间 1000～1039，其中，内存块的首地址为 base_address = 1000。</p>
<p>计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。当计算机需要随机访问数组中的某个元素时，它会首先通过下面的寻址公式，计算出该元素存储的内存地址：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a[i]_address = base_address + i * data_type_size</div></pre></td></tr></table></figure>
<p>其中 data_type_size 表示数组中每个元素的大小。我们举的这个例子里，数组中存储的是 int 类型数据，所以 data_type_size 就为 4 个字节。</p>
<h3 id="低效的“插入”和“删除”"><a href="#低效的“插入”和“删除”" class="headerlink" title="低效的“插入”和“删除”"></a>低效的“插入”和“删除”</h3><p>数组为了保持内存数据的连续性，会导致插入、删除这两个操作比较。</p>
<h5 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h5><p>假设数组的长度为 n，现在，如果我们需要将一个数据插入到数组中的第 k 个位置。为了把第 k 个位置腾出来，给新来的数据，我们需要将第 k～n 这部分的元素都顺序地往后挪一位。</p>
<p>如果在数组的末尾插入元素，那就不需要移动数据了，这时的时间复杂度为 O(1)。但如果在数组的开头插入元素，那所有的数据都需要依次往后移动一位，所以最坏时间复杂度是 O(n)。因为我们在每个位置插入元素的概率是一样的，所以平均情况时间复杂度为 (1+2+…n)/n=O(n)。</p>
<p>如果一组数组中存储的数据并没有任何规律，数组只是被当作一个存储数据的集合。在这种情况下，如果要将某个数组插入到第 k 个位置，为了避免大规模的数据搬移，我们还有一个简单的办法就是，直接将第 k 位的数据搬移到数组元素的最后，把新的元素直接放入第 k 个位置。</p>
<p>举一个例子。假设数组 a[10] 中存储了如下 5 个元素：a，b，c，d，e。</p>
<p>我们现在需要将元素 x 插入到第 3 个位置。我们只需要将 c 放入到 a[5]，将 a[2] 赋值为 x 即可。最后，数组中的元素如下： a，b，x，d，e，c。</p>
<p><img src="https://static001.geekbang.org/resource/image/3f/dc/3f70b4ad9069ec568a2caaddc231b7dc.jpg" alt=""></p>
<p>利用这种处理技巧，在特定场景下，在第 k 个位置插入一个元素的时间复杂度就会降为 O(1)。</p>
<h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><p>跟插入数据类似，如果我们要删除第 k 个位置的数据，为了内存的连续性，也需要搬移数据，不然中间就会出现空洞，内存就不连续了。</p>
<p>和插入类似，如果删除数组末尾的数据，则最好情况时间复杂度为 O(1)；如果删除开头的数据，则最坏情况时间复杂度为 O(n)；平均情况时间复杂度也为 O(n)。</p>
<p>实际上，在某些特殊场景下，我们并不一定非得追求数组中数据的连续性。如果我们将多次删除操作集中在一起执行，将会提高删除的效率。</p>
<p>我们继续来看例子。数组 a[10] 中存储了 8 个元素：a，b，c，d，e，f，g，h。现在，我们要依次删除 a，b，c 三个元素。</p>
<p><img src="https://static001.geekbang.org/resource/image/b6/e5/b69b8c5dbf6248649ddab7d3e7cfd7e5.jpg" alt=""></p>
<p>为了避免 d，e，f，g，h 这几个数据会被搬移三次，我们可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移（<strong>JVM 标记清除垃圾回收算法的核心思想</strong>）。</p>
<h3 id="容器能否完全替代数组？"><a href="#容器能否完全替代数组？" class="headerlink" title="容器能否完全替代数组？"></a>容器能否完全替代数组？</h3><p>针对数组类型，很多语言都提供了容器类，比如 Java 中的 ArrayList、C++ STL 中的 vector。</p>
<p>以 Java 为例，我们几乎天天在用 ArrayList，它的底层实现就是靠数组的。那它与数组相比，到底有哪些优势呢？</p>
<p>ArrayList 最大的优势就是可以将很多数组操作的细节封装起来。比如前面提到的数组插入、删除数据时需要搬移其他数据等，如果要把某个数据插入到超过数组大小的位置时，我们就需要重新分配一块更大的空间，将原来的数据复制过去，然后然后再将新的数据插入。另外，它还有一个优势，就是支持动态扩容，每次存储空间不够的时候，它都会将空间自动扩容为 1.5 倍。不过，因为扩容操作涉及内存申请和数据搬移，是比较耗时的。所以，如果事先能确定需要存储的数据大小，最好在创建 ArrayList 的时候事先指定数据大小。</p>
<h5 id="容器和数组使用场景总结"><a href="#容器和数组使用场景总结" class="headerlink" title="容器和数组使用场景总结"></a>容器和数组使用场景总结</h5><ol>
<li>Java ArrayList 无法存储基本类型，比如 int、long，需要封装为 Integer、Long 类，而 Autoboxing、Unboxing 则有一定的性能消耗，所以如果特别关注性能，或者希望使用基本类型，就可以选用数组。</li>
<li>如果数据大小事先已知，并且对数据的操作非常简单，用不到 ArrayList 提供的大部分方法，也可以直接使用数组。</li>
<li>当要表示多维数组时，用数组往往会更加直观。比如 Object []<strong>[]</strong>array；而用容器的话则需要这样定义：ArrayList&lt;<strong>ArrayList</strong>&gt; array。</li>
</ol>
<p>总结一下，对于业务开发，直接使用容器就足够了。但如果是做一些非常底层的开发，比如开发网络框架，性能的优化需要做到极致，这个时候数组就会优于容器，成为首选。</p>
<h3 id="为什么数组要从-0-开始编号，而不是从-1-开始"><a href="#为什么数组要从-0-开始编号，而不是从-1-开始" class="headerlink" title="为什么数组要从 0  开始编号，而不是从 1 开始"></a>为什么数组要从 0  开始编号，而不是从 1 开始</h3><p>从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移”。如果用 a 来表示数组的首地址，a[0] 就是偏移为 0 的位置，也就是首地址，a[k] 就表示偏移 k 个 type_size 的位置，所以计算 a[k] 的内存地址只需要用这个公式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a[k]_address = base_address + k * type_size</div></pre></td></tr></table></figure>
<p>如果数组从 1 开始计数，那计算数组元素 a[k] 的内存地址就会变为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a[k]_address = base_address + (k-<span class="number">1</span>) * type_size</div></pre></td></tr></table></figure>
<p>对比两个公式，我们不难发现，从 1 开始编号，每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令。</p>
<p>数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致。所以为了减少一次减法操作，数组选择了从 0 开始编号，而不是从 1 开始。</p>
<h3 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h3><p>数组可以说是最基础、最简单的数据结构了。数组用一块连续的内存空间，来存储相同类型的一组数据，最大的特点就是支持随机访问，但插入、删除操作也因此变得比较低效，平均情况时间复杂度为 O(n)。在平时的业务开发中，我们可以直接使用编程语言提供的容器类，但是，如果是特别底层的开发，直接使用数组可能会更合适。</p>
]]></content>
      
        <categories>
            
            <category> 数据结构和算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数据结构和算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[复杂度分析(下)]]></title>
      <url>/2018/09/28/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>复杂度分析除了<a href="https://airxiao.github.io/2018/09/26/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8A%EF%BC%89/#more" target="_blank" rel="external">复杂度分析(上)</a>中介绍的内容，还有这四个知识点，分别是：<strong>最好情况时间复杂度</strong>、<strong>最坏情况时间复杂度</strong>、<strong>平均情况时间复杂度</strong>、<strong>均摊时间复杂度</strong>。</p>
<a id="more"></a>
<h3 id="最好、最坏情况时间复杂度"><a href="#最好、最坏情况时间复杂度" class="headerlink" title="最好、最坏情况时间复杂度"></a>最好、最坏情况时间复杂度</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// n 表示数组 array 的长度</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> n, <span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> pos = -<span class="number">1</span>;</div><div class="line">  <span class="keyword">for</span> (; i &lt; n; ++i) &#123;</div><div class="line">    <span class="keyword">if</span> (array[i] == x) &#123;</div><div class="line">       pos = i;</div><div class="line">       <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> pos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码的执行时间和变量 x 有关，变量 x 可能出现在数组的任意位置。如果数组中第一个元素正好是要查找的变量 x，那就不需要继续遍历剩下的 n-1 个数据了，那时间复杂度就是 O(1)。但如果数组中不存在变量 x，那我们就需要把整个数组都遍历一遍，时间复杂度就成了 O(n)。不同的情况下，这段代码的时间复杂度是不一样的。</p>
<p>最好情况时间复杂度就是，在最理想的情况下，执行这段代码的时间复杂度。就如上面代码中要查找的变量 x 正好在数组的第一个元素，这时候的时间复杂度就是最好情况时间复杂度。</p>
<p>同理，最坏情况时间复杂度就是，在最糟糕的情况，执行这段代码的时间复杂度。就如上面代码的数组中没有要查找的变量 x，这时候要把整个数组都便利一遍才行，这种情况下对应的就是最坏情况时间复杂度。</p>
<h3 id="平均情况时间复杂度"><a href="#平均情况时间复杂度" class="headerlink" title="平均情况时间复杂度"></a>平均情况时间复杂度</h3><p>最好情况时间复杂度和最坏情况时间复杂度对应的都是极端情况下的都是极端情况下的代码复杂度，发生的概率其实并不大。为了更好地表示平均情况下的复杂度，我们需要引入另一个概念：平均情况时间复杂度。</p>
<p>还是以上面的代码为例子。要查找的变量 x 要么在数组里，要么就不在数组里。这两种情况对应的概率统计起来很麻烦，为了方便理解，我们假设在数组中与不在数组中的概率都为 1/2。另外，要查找的数据出现在 0～n-1 这 n 个位置的概率也是一样的，为 1/n。所以，根据概率乘法法则，要查找的数据出现在 0～n-1 中任意位置的概率就是 1/(2n)。</p>
<p>如果我们把每种情况发生的概率也考虑进去，那平均时间复杂度的计算过程就变成了这样：</p>
<p><img src="https://static001.geekbang.org/resource/image/36/7f/36c0aabdac69032f8a43368f5e90c67f.jpg" alt=""></p>
<p>这个值就是概率论中的<strong>加权平均值</strong>，也叫作<strong>期望值</strong>，所以平均时间复杂度的全称应该叫<strong>加权平均时间复杂度</strong>或者<strong>期望时间复杂度</strong>。</p>
<p>引入概率之后，前面那段代码的加权平均值为 (3n+1)/4。用大 O 表示法来表示，去掉系数和常量，这段代码的加权平均时间复杂度仍然是 O(n)。</p>
<p>实际上，在大多数情况下，我们并不需要区分最好、最坏、平均情况时间复杂度三种情况。只有同一块代码在不同的情况下，时间复杂度有量级的差距，才会使用这三种复杂度表示法来区分。</p>
<h3 id="均摊时间复杂度"><a href="#均摊时间复杂度" class="headerlink" title="均摊时间复杂度"></a>均摊时间复杂度</h3><p>均摊时间复杂度，它对应的分析方法是摊还分析（或者叫平摊分析）。均摊时间复杂度，听起来跟平均时间复杂度有点儿像，这两个概念确实非常容易弄混。</p>
<p>大部分情况下，我们并不需要区分最好、最坏、平均三种复杂度。平均复杂度只在某些特殊情况下才会用到，而均摊时间复杂度应用的场景比它更加特殊、更加有限。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// array 表示一个长度为 n 的数组</span></div><div class="line"><span class="comment">// 代码中的 array.length 就等于 n</span></div><div class="line"><span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[n];</div><div class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (count == array.length) &#123;</div><div class="line">      <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; ++i) &#123;</div><div class="line">         sum = sum + array[i];</div><div class="line">      &#125;</div><div class="line">      array[<span class="number">0</span>] = sum;</div><div class="line">      count = <span class="number">1</span>;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   array[count] = val;</div><div class="line">   ++count;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码实现了一个往数组中插入数据的功能。当数组满了之后，也就是代码中的 count == array.length 时，我们用 for 循环遍历数组求和，将求和之后的 sum 值放到数组的第一个位置，然后再将新的数据插入。但如果数组一开始就有空闲空间，则直接将数据插入数组。</p>
<p>我们用刚讲到的三种时间复杂度的分析方法来分析一下。</p>
<p>最理想的情况下，数组中有空闲空间，我们只需要将数据插入到数组下标为 count 的位置就可以了，所以最好情况时间复杂度为 O(1)。最坏的情况下，数组中没有空闲空间了，我们需要先做一次数组的遍历求和，然后再将数据插入，所以最坏情况时间复杂度为 O(n)。</p>
<p>我们再通过概率论的方法来分析下平均时间复杂度。</p>
<p>假设数组的长度是 n，在数组有空闲空间可以插入的时候，根据数据插入的位置的不同，我们可以分为 n 种情况，每种情况的时间复杂度是 O(1)。除此之外,在数组没有空闲空间时插入一个数据，这个时候的时间复杂度是 O(n)。而且，这 n+1 种情况发生的概率一样，都是 1/(n+1)。所以，根据加权平均的计算方法，我们求得的平均时间复杂度就是：</p>
<p><img src="https://static001.geekbang.org/resource/image/6d/ed/6df62366a60336d9de3bc34f488d8bed.jpg" alt=""></p>
<p>对于 insert() 函数来说，O(1) 时间复杂度的插入和 O(n) 时间复杂度的插入，出现的频率是非常有规律的，而且有一定的前后时序关系，一般都是一个 O(n) 插入之后，紧跟着 n-1 个 O(1) 的插入操作，循环往复。</p>
<p>针对这种特殊的场景，我们引入了一种更加简单的分析方法：<strong>摊还分析法</strong>，通过摊还分析得到的时间复杂度我们起了一个名字，叫<strong>均摊时间复杂度</strong>。</p>
<h4 id="使用摊还分析法来分析算法的均摊时间复杂度："><a href="#使用摊还分析法来分析算法的均摊时间复杂度：" class="headerlink" title="使用摊还分析法来分析算法的均摊时间复杂度："></a>使用摊还分析法来分析算法的均摊时间复杂度：</h4><p>还是以上面的代码为例子。每一次 O(n) 的插入操作，都会跟着 n-1 次 O(1) 的插入操作，所以把耗时多的那次操作均摊到接下来的 n-1 次耗时少的操作上，均摊下来，这一组连续的操作的均摊时间复杂度就是 O(1)。这就是均摊分析的大致思路。</p>
<p>均摊时间复杂度和摊还分析应用场景比较特殊，所以我们并不会经常用到。总结一下它们的应用场景就是：</p>
<p>对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度。</p>
<p><strong>均摊时间复杂度就是一种特殊的平均时间复杂度</strong>，没必要花太多精力去区分它们。我们最应该掌握的是它的分析方法，摊还分析。至于分析出来的结果是叫平均还是叫均摊，这只是个说法，并不重要。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>最好情况时间复杂度、最坏情况时间复杂度、平均情况时间复杂度、均摊时间复杂度，之所以有这样的区分是因为同一段代码，在不同输入的情况下，复杂度量级有可能是不一样的。有了这几个概念后，我们可以更加全面地表示一段代码的执行效率。</p>
]]></content>
      
        <categories>
            
            <category> 数据结构和算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数据结构和算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[复杂度分析（上）]]></title>
      <url>/2018/09/26/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>复杂度分析是整个算法学习的精髓，只要掌握了它，数据结构和算法的内容基本上就掌握了一半。</p>
<a id="more"></a>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>时间复杂度的全称是渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系。</p>
<h5 id="大-O-复杂度表示法"><a href="#大-O-复杂度表示法" class="headerlink" title="大 O 复杂度表示法"></a>大 O 复杂度表示法</h5><p><img src="https://static001.geekbang.org/resource/image/22/ef/22900968aa2b190072c985a08b0e92ef.png" alt="大 O 复杂度表示法"></p>
<p>其中，T(n)表示代码执行的时间；n 表示数据规模的大小；f(n) 表示每行代码执行的次数总和。因为这是一个公式，所以用 f(n) 来表示。公式中的 O，表示代码的执行时间 T(n) 与 f(n) 表达式成正比。</p>
<p>大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度，简称时间复杂度。</p>
<p>当 n 很大时，公式中的低阶、常量、系数三部分并不左右增长趋势，所以都可以忽略。我们只需要记录一个最大量级就可以了。也就是说：总的时间复杂度就等于量级最大的那段代码的时间复杂度。</p>
<h5 id="几种常见时间复杂度实例分析"><a href="#几种常见时间复杂度实例分析" class="headerlink" title="几种常见时间复杂度实例分析"></a>几种常见时间复杂度实例分析</h5><p><img src="https://static001.geekbang.org/resource/image/37/0a/3723793cc5c810e9d5b06bc95325bf0a.jpg" alt="几种常见时间复杂度实例分析"></p>
<p>图中的复杂度量级，可以分为多项式量级和非多项式量级。其中，非多项式量级只有两个：O(2n) 和 O(n!)。</p>
<p>当数据规模 n 越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长。所以，非多项式时间复杂度的算法其实是非常低效的算法。而几种常见的多项式时间复杂度如下：</p>
<ol>
<li><p>O(1)</p>
<p>O(1) 只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span> <span class="keyword">int</span> i = <span class="number">8</span>;</div><div class="line"><span class="number">2</span> <span class="keyword">int</span> j = <span class="number">6</span>;</div><div class="line"><span class="number">3</span> <span class="keyword">int</span> sum = i + j;</div></pre></td></tr></table></figure>
<p>一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。</p>
</li>
</ol>
<ol>
<li><p>O(logn)、O(nlogn)</p>
<p>对数阶时间复杂度非常常见，同时也是最难分析的一种时间复杂度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span> i=<span class="number">1</span>;</div><div class="line"><span class="number">2</span> <span class="keyword">while</span> (i &lt;= n)  &#123;</div><div class="line"><span class="number">3</span>   i = i * <span class="number">2</span>;</div><div class="line"><span class="number">4</span> &#125;</div></pre></td></tr></table></figure>
<p>从代码中可以看出，变量 i 的值从 1 开始取，每循环一次就乘以 2。当大于 n 时，循环结束。如果把它一个一个列出来，就应该是这个样子的：</p>
<p><img src="https://static001.geekbang.org/resource/image/9b/9a/9b1c88264e7a1a20b5954be9bc4bec9a.jpg" alt=""></p>
<p>所以，我们只要知道 x 值是多少，就知道这行代码执行的次数了。x=log2n，所以，这段代码的时间复杂度就是 O(log2n)。</p>
<p>在采用大 O 标记复杂度的时候，可以忽略系数，即 O(Cf(n)) = O(f(n))。因此，在对数阶时间复杂度的表示方法里，我们忽略对数的“底”，统一表示为 O(logn)。</p>
</li>
<li><p>O(m+n)、O(m*n)</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> sum_1 = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> i = <span class="number">1</span>;</div><div class="line">  <span class="keyword">for</span> (; i &lt; m; ++i) &#123;</div><div class="line">    sum_1 = sum_1 + i;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">int</span> sum_2 = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> j = <span class="number">1</span>;</div><div class="line">  <span class="keyword">for</span> (; j &lt; n; ++j) &#123;</div><div class="line">    sum_2 = sum_2 + j;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> sum_1 + sum_2;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从代码中可以看出，m 和 n 是表示两个数据规模。我们无法事先评估 m 和 n 谁的量级大，所以我们在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。所以，上面代码的时间复杂度就是 O(m+n)。</p>
</li>
</ol>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>空间复杂度全称就是渐进空间复杂度，表示算法的存储空间与数据规模之间的增长关系。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span> <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line"><span class="number">2</span>  <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line"><span class="number">3</span>  <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[n];</div><div class="line"><span class="number">4</span>  <span class="keyword">for</span> (i; i &lt;n; ++i) &#123;</div><div class="line"><span class="number">5</span>    a[i] = i * i;</div><div class="line"><span class="number">6</span>  &#125;</div><div class="line"></div><div class="line"><span class="number">7</span>  <span class="keyword">for</span> (i = n-<span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</div><div class="line"><span class="number">8</span>    print out a[i]</div><div class="line"><span class="number">9</span>  &#125;</div><div class="line"><span class="number">10</span>&#125;</div></pre></td></tr></table></figure>
<p>可以看到，第 2 行代码中，我们申请了一个空间存储变量 i，但是它是常量阶的，跟数据规模 n 没有关系，所以我们可以忽略。第 3 行申请了一个大小为 n 的 int 类型数组，除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是 O(n)。</p>
<p>我们常见的空间复杂度就是 O(1)、O(n)、O(n2 )，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率与数据规模之间的增长关系，可以粗略地表示，越高阶复杂度的算法，执行效率越低。</p>
<p><img src="https://static001.geekbang.org/resource/image/49/04/497a3f120b7debee07dc0d03984faf04.jpg" alt=""></p>
<p>常见的复杂度并不多，从低阶到高阶有：O(1)、O(logn)、O(n)、O(nlogn)、O(n2 )。对于绝大多数数据结构和算法来说，其复杂度无外乎这几个。</p>
]]></content>
      
        <categories>
            
            <category> 数据结构和算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数据结构和算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[视频硬解码]]></title>
      <url>/2018/08/12/%E8%A7%86%E9%A2%91%E7%A1%AC%E8%A7%A3%E7%A0%81/</url>
      <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>实时视频在播放的时候出现卡顿和延迟现象，经分析是因为视频在 C 层采用的是软解码的方式进行播放，因此决定在 Java 层改用硬解码方式。</p>
<a id="more"></a>
<h3 id="软解码和硬解码区别"><a href="#软解码和硬解码区别" class="headerlink" title="软解码和硬解码区别"></a>软解码和硬解码区别</h3><ul>
<li>软解码：使用 CPU 进行编码，实现直接、简单，参数调整方便，升级易，但 CPU 负载重，性能较硬编码低。</li>
<li>硬解码：使用显卡 GPU、专用的 DSP、FPGA、ASIC 芯片等方式进行编码，性能高。</li>
</ul>
<p>可见使用硬解码的方式能降低 CPU 的负载，使得视频能播放得更加流畅。</p>
<h3 id="硬解码实现"><a href="#硬解码实现" class="headerlink" title="硬解码实现"></a>硬解码实现</h3><h4 id="1-初始化解码器"><a href="#1-初始化解码器" class="headerlink" title="1.初始化解码器"></a>1.初始化解码器</h4><p>视频的硬解码主要用到了 MediaCodec 类，对于开发者来说只要把 H.264 标准的码流通过这个类进行解码就可以得到 YUV 格式的视频了，而解码过程也是 Android 都已经封装好了，所以使用起来十分方便。本人也对硬解部分做了封装，有需要的小伙伴也可以直接拿去使用（<a href="https://github.com/airxiao/MediaDecoder" target="_blank" rel="external">Github传送门</a>）。以下的讲解也是基于我封装的基础上进行讲解的。</p>
<p>对于使用视频硬解，可以在 SurfaceView 的 surfaceCreated 回调里面对 MediaCodec 进行初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> MediaCodecDecoder <span class="title">createNewDecoder</span><span class="params">(SurfaceHolder holder)</span> </span>&#123;</div><div class="line">    VDConfig vdConfig = <span class="keyword">new</span> VDConfig();</div><div class="line">    vdConfig.setFramerate(DEFAULT_RATE);</div><div class="line">    vdConfig.setHeight(holder.getSurfaceFrame().height());</div><div class="line">    vdConfig.setWidth(holder.getSurfaceFrame().width());</div><div class="line">    vdConfig.setDisplay(holder);</div><div class="line">    MediaCodecDecoder mediaCodecDecoder = <span class="keyword">new</span> MediaCodecDecoder();</div><div class="line">    mediaCodecDecoder.setConfig(vdConfig);</div><div class="line">    mediaCodecDecoder.start();</div><div class="line">    <span class="keyword">return</span> mediaCodecDecoder;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>初始化的过程主要是创建一个新的 MediaCodec，而在我封装的 MediaCodecDecoder 里面主要是新建了一个进行解码的线程和一个存储视频帧的队列。通过调用 mediaCodecDecoder.start() 就完成了初始化的过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mIsStart) &#123;</div><div class="line">        Log.w(TAG, <span class="string">"is already start"</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (mVDConfig == <span class="keyword">null</span>) &#123;</div><div class="line">        Log.e(TAG, <span class="string">"start without decode config"</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    initMediaCodec();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">initMediaCodec</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mIsStart) &#123;</div><div class="line">       <span class="keyword">return</span>; </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        mMediaCodec = MediaCodec.createDecoderByType(MIME_TYPE);</div><div class="line">        MediaFormat format = MediaFormat.createVideoFormat(MIME_TYPE,        mVDConfig.getWidth(), mVDConfig.getHeight());</div><div class="line">        mMediaCodec.configure(format, mVDConfig.getDisplay().getSurface(), <span class="keyword">null</span>, <span class="number">0</span>);</div><div class="line">        mMediaCodec.start();</div><div class="line">        mIsStart = <span class="keyword">true</span>;</div><div class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">        Log.e(TAG, <span class="string">"initMediaCodec Exception"</span> + e.getMessage());</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到在初始化主要是设置了一些基本信息，比如要解码的码流类型，视频帧的宽高以及设置解码完后要进行播放的 SurfaveView 控件。</p>
<h4 id="2-解码"><a href="#2-解码" class="headerlink" title="2.解码"></a>2.解码</h4><p>初始化完成后就可以进行解码操作了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * H.264码流回调</div><div class="line"> * <span class="doctag">@param</span> index 窗口序号</div><div class="line"> * <span class="doctag">@param</span> data 码流</div><div class="line"> * <span class="doctag">@param</span> len 码流长度</div><div class="line"> * <span class="doctag">@param</span> rate 帧率</div><div class="line"> * <span class="doctag">@param</span> timestamp 时间戳</div><div class="line"> * <span class="doctag">@param</span> width 视频宽度</div><div class="line"> * <span class="doctag">@param</span> height 视频高度</div><div class="line"> * <span class="doctag">@param</span> subType 视频帧类型(I P B)</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onVideoDataCallback</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">byte</span>[] data, <span class="keyword">int</span> len, <span class="keyword">int</span> rate, <span class="keyword">long</span> timestamp, <span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="keyword">int</span> subType)</span> </span>&#123;</div><div class="line">    Log.d(<span class="string">"EventManager"</span>, <span class="string">"index:"</span> + index + <span class="string">",dataLen:"</span> + data.length + <span class="string">",len:"</span> + len + <span class="string">",rate:"</span> + rate + <span class="string">",timestamp:"</span> + timestamp + <span class="string">",width:"</span> + width + <span class="string">",height:"</span> + height);</div><div class="line">    mediaCodecDecoder.sendData(<span class="keyword">new</span> VideoData(subType, data));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>假设 onVideoDataCallback 是一个码流回调接口，那就可以直接调用解码器的 sendData() 进行解码操作了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendData</span><span class="params">(VideoData videoData)</span> </span>&#123;</div><div class="line">    decoderQueue.offer(videoData);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到主要是给解码器中的队列塞进待解码数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public MediaCodecDecoder() &#123;</div><div class="line">   mFuture = ThreadPool.submit(this);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面我们说到解码器里面除了解码队列还有一个解码线程，解码线程是在初始化解码器的时候就创建的，而且还是从线程池中获取的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">while</span> (!isFinish) &#123;</div><div class="line">                VideoData data = decoderQueue.take();<span class="comment">//方法阻塞，有数据时继续执行。</span></div><div class="line"><span class="comment">//               Log.d(TAG, "queue size:" + decoderQueue.size() + " ,Frame_Type:" + data.getSubType());</span></div><div class="line">                decodeData(data);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>通过线程的 run() 方法可以看到线程内部是一个 while 循环，循环内则是通过队列的 take() 方法获取到队列出口的第一个数据然后进行 decodeData() 解码处理。线程中的队列是 LinkedBlockingDeque，它是一个线程同步的阻塞队列，这样能避免在没有码流上来的情况下子线程一直运行造成的资源损耗。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">decodeData</span><span class="params">(VideoData videodata)</span> </span>&#123;</div><div class="line">  	<span class="keyword">if</span> (decoderQueue.size() &gt;= <span class="number">10</span> * mVDConfig.getFramerate()) &#123;</div><div class="line">	isIncrease = <span class="keyword">false</span>;</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isIncrease &amp;&amp; decoderQueue.size() &lt;= mVDConfig.getFramerate()) &#123;</div><div class="line">	isIncrease = <span class="keyword">true</span>;</div><div class="line">          isDecode = <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line">  	</div><div class="line">  	<span class="keyword">if</span> (!isIncrease &amp;&amp; videodata.getSubType() != <span class="number">1</span>) &#123;</div><div class="line">	<span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (!isDecode) &#123;</div><div class="line">          <span class="keyword">if</span> (videodata.getSubType() == <span class="number">1</span>) &#123;</div><div class="line">              isDecode = <span class="keyword">true</span>;</div><div class="line">          &#125; <span class="keyword">else</span> &#123;</div><div class="line">              <span class="keyword">return</span>;</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">  	</div><div class="line">  	<span class="keyword">byte</span>[] data = videodata.getData();</div><div class="line">  	</div><div class="line">      <span class="keyword">if</span> (!mIsStart) &#123;</div><div class="line">          Log.w(TAG, <span class="string">"decodeData fail decoder is not start"</span>);</div><div class="line">          <span class="keyword">return</span>;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (data == <span class="keyword">null</span>) &#123;</div><div class="line">          Log.w(TAG, <span class="string">"decodeData data is null"</span>);</div><div class="line">          <span class="keyword">return</span>;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">//重置开始时间</span></div><div class="line">      startTime = System.currentTimeMillis();</div><div class="line"></div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">          ByteBuffer[] buffers = mMediaCodec.getInputBuffers();</div><div class="line">          <span class="comment">//-1表示一直等待；0表示不等待；其他大于0的参数表示等待毫秒数</span></div><div class="line">          <span class="keyword">int</span> index = mMediaCodec.dequeueInputBuffer(-<span class="number">1</span>);</div><div class="line"></div><div class="line">          <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</div><div class="line">              ByteBuffer buffer = buffers[index];</div><div class="line">              buffer.clear();</div><div class="line">              buffer.put(data, <span class="number">0</span>, data.length);</div><div class="line">              mMediaCodec.queueInputBuffer(index, <span class="number">0</span>, data.length, mCount * <span class="number">1000000</span> /    mVDConfig.getFramerate(), <span class="number">0</span>);</div><div class="line">              mCount++;</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          MediaCodec.BufferInfo bufferInfo = <span class="keyword">new</span> MediaCodec.BufferInfo();</div><div class="line">          <span class="keyword">int</span> outputIndex = mMediaCodec.dequeueOutputBuffer(bufferInfo, <span class="number">11000</span>);</div><div class="line">          <span class="keyword">while</span> (outputIndex &gt;= <span class="number">0</span>) &#123;</div><div class="line">              mMediaCodec.releaseOutputBuffer(outputIndex, <span class="keyword">true</span>);</div><div class="line">              outputIndex = mMediaCodec.dequeueOutputBuffer(bufferInfo, <span class="number">11000</span>);</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">if</span> (decoderQueue.size() &lt; mVDConfig.getFramerate()) &#123;</div><div class="line">              <span class="comment">//线程休眠</span></div><div class="line">              sleepThread(mVDConfig.getFramerate(), startTime, System.currentTimeMillis());</div><div class="line">          &#125;</div><div class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">          Log.e(TAG, <span class="string">"decodeData Exception"</span>);</div><div class="line">          e.printStackTrace();</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>视频数据 dequeueOutputBuffer() 方法塞给 MediaCodec 进行硬解处理（要注意第三个参数是时间戳，既需要播放的时间，因此要线性增加，注意单位是微秒），然后再通过 dequeueOutputBuffer() 函数取出解码后的视频数据。</p>
<p>视频在播放的时候是以一帧一帧的形式播放的，类似于一张张图片播放。如果在单通道播放的情况下注释掉 sleepThread() 函数会发现视频播放很快，原因在于每一帧数据上来解码器都能很快进行操作并播放，比如这一帧的数据是在第5秒钟播放的，现在在第2秒钟就播了，而且前面的视频帧全部都提前播放了。所以对于每一帧视频做了相应的处理，使他们能以相对正常的进度播放。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sleepThread</span><span class="params">(<span class="keyword">int</span> rate, <span class="keyword">long</span> startTime, <span class="keyword">long</span> endTime)</span> </span>&#123;</div><div class="line">    <span class="comment">//计算需要休眠的时间</span></div><div class="line">    <span class="keyword">long</span> time = <span class="number">1000</span> / rate - (endTime - startTime);</div><div class="line">    <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread.sleep(time);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>具体处理的策略就是每一帧视频播放的间隔减去代码解码需要的时间就是线程需要睡眠的时间。但是在实际的使用过程中，我们发现如果同时打开多路视频的情况，这时候队列内的数据会不断增加，这会导致越播越慢的情况。比如一个视频要一分钟播放，但是却播了两分钟，原因是由于在多路解码的情况下如果超出硬件设备所能支持的最大硬解限制就会导致解码的时间比帧间隔的时间还长，造成延迟的现象。这时候为了保证实时性，当队列内的视频帧数据超过一秒钟（可根据实际需求更改）的大小时，我们不会对视频帧进行睡眠处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">  	<span class="keyword">if</span> (decoderQueue.size() &gt;= <span class="number">10</span> * mVDConfig.getFramerate()) &#123;</div><div class="line">	isIncrease = <span class="keyword">false</span>;</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isIncrease &amp;&amp; decoderQueue.size() &lt;= mVDConfig.getFramerate()) &#123;</div><div class="line">	isIncrease = <span class="keyword">true</span>;</div><div class="line">          isDecode = <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line">  	</div><div class="line">  	<span class="keyword">if</span> (!isIncrease &amp;&amp; videodata.getSubType() != <span class="number">1</span>) &#123;</div><div class="line">	<span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line">      <span class="comment">// 当队列大小小于一秒钟播放的帧数时，直到 I 帧出来后才开始所有类型帧的解码</span></div><div class="line">      <span class="keyword">if</span> (!isDecode) &#123;</div><div class="line">          <span class="keyword">if</span> (videodata.getSubType() == <span class="number">1</span>) &#123;</div><div class="line">              isDecode = <span class="keyword">true</span>;</div><div class="line">          &#125; <span class="keyword">else</span> &#123;</div><div class="line">              <span class="keyword">return</span>;</div><div class="line">          &#125;</div><div class="line">      &#125;</div></pre></td></tr></table></figure>
<p>在decodeData() 函数的前面部分存在了这样的一段代码，它的策略是为了保证存在播放多路视频的需求，但是又要尽可能的保证实时性。当多路视频的情况下，设备硬解码的时间大于帧间隔，这时候队列内的数据越来越多，当数据的大小达到可以播放 10 秒（可根据实际需求更改）视频的时候，这时候只对队列内的 I 帧（关键帧）进行解码播放，而 P帧 和 B 帧 统统扔掉，当队列大小小于一秒钟（可根据实际需求更改）播放的帧数时，直到 I 帧出来后又让解码器可以解析所有类型的视频帧，这样即可保证视频的实时性（当然也有其他的策略）。</p>
<h4 id="3-释放解码器"><a href="#3-释放解码器" class="headerlink" title="3.释放解码器"></a>3.释放解码器</h4><p>当视频解码完成后，要对解码器进行释放处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</div><div class="line">        setFinish(<span class="keyword">true</span>);</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (!mIsStart) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">try</span>&#123;</div><div class="line">            mMediaCodec.stop();</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            Log.e(TAG, <span class="string">"stop stop Exception"</span> + e.getMessage());</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">try</span>&#123;</div><div class="line">            mMediaCodec.release();</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            Log.e(TAG, <span class="string">"stop release Exception"</span> + e.getMessage());</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"><span class="comment">//        Log.e(TAG, "stop MediaCodec success");</span></div><div class="line">        startTime = <span class="number">0</span>;</div><div class="line">        mVDConfig = <span class="keyword">null</span>;</div><div class="line">        mMediaCodec = <span class="keyword">null</span>;</div><div class="line">        mIsStart = <span class="keyword">false</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>设置 setFinish(true) 释放掉线程的循环，再依次调用 mMediaCodec.stop() 和 mMediaCodec.release() 停止解码并释放。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上是本人基于自己对视频硬解的理解封装的解码器，其中所涉及的播放策略可根据自己的实际需求进更改并改进。</p>
<p><a href="https://github.com/airxiao/MediaDecoder" target="_blank" rel="external">Github地址：https://github.com/airxiao/MediaDecoder</a></p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 视频解码 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android 屏幕适配总结]]></title>
      <url>/2018/02/28/Android-%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>Android 的碎片化越来越严重，因此屏幕适配十分重要但又比较繁琐，现对 Android 的屏幕适配做下总结。</p>
<a id="more"></a>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Android 屏幕适配必须了解的几个概念：</p>
<ul>
<li><p>px</p>
<p>意为像素，是用来计算数码影像的最小单位。</p>
</li>
<li><p>in</p>
<p>表示英寸，指的是手机屏幕对角线长度（我们平时说手机 xx 寸就是指英寸）。</p>
</li>
<li><p>dpi</p>
<p>表示每英寸点数，即每英寸包含像素个数。比如320X480分辨率的手机，宽2英寸，高3英寸, 每英寸包含的像素点的数量为320/2=160dpi（横向）或480/3=160dpi（纵向），160就是这部手机的dpi，横向和纵向的这个值都是相同的。</p>
</li>
<li><p>density</p>
<p>屏幕密度，density和dpi的关系为 density = dpi/160</p>
</li>
<li><p>dp</p>
<p>也即dip，设备独立像素，device independent pixels的缩写，Android特有的单位。在屏幕密度dpi = 160屏幕上，1dp = 1px。</p>
</li>
</ul>
<h3 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h3><p>各类型设备屏幕对应的 dpi 等级、屏幕像素密度、屏幕密度如下表。</p>
<table>
<thead>
<tr>
<th style="text-align:center">设备 dpi 等级</th>
<th style="text-align:center">屏幕像素密度（dpi）</th>
<th style="text-align:center">屏幕密度（density）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ldpi</td>
<td style="text-align:center">120</td>
<td style="text-align:center">0.75</td>
</tr>
<tr>
<td style="text-align:center">mdpi</td>
<td style="text-align:center">160</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">dpi</td>
<td style="text-align:center">240</td>
<td style="text-align:center">1.5</td>
</tr>
<tr>
<td style="text-align:center">xhdpi</td>
<td style="text-align:center">320</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">xxhdpi</td>
<td style="text-align:center">480</td>
<td style="text-align:center">3</td>
</tr>
</tbody>
</table>
<p>我们知道一个 Android 项目的资源文件下有很多类型的 drawable 文件夹，分别对应不同的 dpi。</p>
<table>
<thead>
<tr>
<th style="text-align:center">drawable 文件等级</th>
<th style="text-align:center">dpi（drawable）</th>
<th style="text-align:center">density（drawable）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">drawable-ldpi</td>
<td style="text-align:center">120</td>
<td style="text-align:center">0.75</td>
</tr>
<tr>
<td style="text-align:center">drawable-mdpi</td>
<td style="text-align:center">160</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">drawable-hdpi</td>
<td style="text-align:center">240</td>
<td style="text-align:center">1.5</td>
</tr>
<tr>
<td style="text-align:center">drawable-xhdpi</td>
<td style="text-align:center">320</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">drawable-xxhdpi</td>
<td style="text-align:center">480</td>
<td style="text-align:center">3</td>
</tr>
</tbody>
</table>
<p><strong>当我们在宽高都设置为 wrap_content 的 ImageView 控件中插入一张图片，那么这张图片的尺寸换算成 dp 该如何计算呢？显示在设备上又应该是多少像素呢？</strong></p>
<ol>
<li>dp = 图片尺寸像素 / 图片所在drawable 文件等级的 density</li>
<li>设备上显示的像素 = dp * 设备屏幕密度（density）</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>在宽高都设置为 wrap_content 的 ImageView 控件中插入一张图片，如果图片依次放在 drawable 文件 dpi 越大的文件中，控件的 dp 就越小，ImageView 在设备上显示的尺寸也越小，图片在 ImageView 展示就会被压缩。</li>
<li>在宽高都设置为 wrap_content 的 ImageView 控件中插入一张来自 drawable-mdpi 文件等级的 120 * 120 图片，其宽高的 dp = 120 / 1 = 120，其展示效果和把图片放入一个宽高都设置为 120dp 的控件中的展示效果一样。但是如果把图片放到大于宽高都设置为 120dp 的控件中，那么图片就会被拉伸显得模糊；反之则会被压缩。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 适配 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[从源码角度分析 Handler、Looper、Message、MessageQuene]]></title>
      <url>/2018/02/26/%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90-Handler%E3%80%81Looper%E3%80%81Message%E3%80%81MessageQuene/</url>
      <content type="html"><![CDATA[<p>Android 的线程间通信主要是通过 Handler 来实现，那么具体是怎么实现运转的呢？下面就从源码的角度进行分析。</p>
<a id="more"></a>
<p>首先从英文字面上这几个单词可以理解为 Handler（执行者），Looper（循环者），Message（消息），MessageQuene（消息队列）。</p>
<h3 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h3><p>我们在子线程使用 Handler 的时候一定要调用 Looper 的以下两个函数（主线程默认已经调用了这两个函数）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">looper.prepare()</div><div class="line">looper.loop()</div></pre></td></tr></table></figure>
<h5 id="looper-prepare"><a href="#looper-prepare" class="headerlink" title="looper.prepare()"></a>looper.prepare()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</div><div class="line">    &#125;</div><div class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 prepare() 方法中，我们看到了一个全局变量 ThreadLocal。ThreadLocal 是一个线程内部的数据存储类，在 Handler 的运行机制中具有很重要的作用，它可以在指定的线程中存储数据，数据存储后，只有在指定线程中可以获取到存储的数据，对于其他线程来说无法获取到数据。对于 Handler 来说，它需要获取当前线程的 Looper，这个时候通过 ThreadLocal 就能轻松实现 Looper 在当前线程中的获取。</p>
<p>在 prepare() 函数中，当前线程下 ThreadLocal 如果取不到 Looper 对象，便会在 ThreadLocal 中创建一个当前线程下的 Looper。继续看 Looper 的构造函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</div><div class="line">    mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</div><div class="line">    mThread = Thread.currentThread();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 可以发现 Looper 内维护了一个消息队列和一个线程。</p>
<h5 id="looper-loop"><a href="#looper-loop" class="headerlink" title="looper.loop()"></a>looper.loop()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Looper me = myLooper();</div><div class="line">    <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">final</span> MessageQueue queue = me.mQueue;</div><div class="line"></div><div class="line">    <span class="comment">// Make sure the identity of this thread is that of the local process,</span></div><div class="line">    <span class="comment">// and keep track of what that identity token actually is.</span></div><div class="line">    Binder.clearCallingIdentity();</div><div class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        Message msg = queue.next(); <span class="comment">// might block</span></div><div class="line">        <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">// No message indicates that the message queue is quitting.</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></div><div class="line">        <span class="keyword">final</span> Printer logging = me.mLogging;</div><div class="line">        <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</div><div class="line">            logging.println(<span class="string">"&gt;&gt;&gt;&gt;&gt; Dispatching to "</span> + msg.target + <span class="string">" "</span> +</div><div class="line">                    msg.callback + <span class="string">": "</span> + msg.what);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">long</span> traceTag = me.mTraceTag;</div><div class="line">        <span class="keyword">if</span> (traceTag != <span class="number">0</span> &amp;&amp; Trace.isTagEnabled(traceTag)) &#123;</div><div class="line">            Trace.traceBegin(traceTag, msg.target.getTraceName(msg));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            msg.target.dispatchMessage(msg);</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</div><div class="line">                Trace.traceEnd(traceTag);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</div><div class="line">            logging.println(<span class="string">"&lt;&lt;&lt;&lt;&lt; Finished to "</span> + msg.target + <span class="string">" "</span> + msg.callback);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Make sure that during the course of dispatching the</span></div><div class="line">        <span class="comment">// identity of the thread wasn't corrupted.</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">long</span> newIdent = Binder.clearCallingIdentity();</div><div class="line">        <span class="keyword">if</span> (ident != newIdent) &#123;</div><div class="line">            Log.wtf(TAG, <span class="string">"Thread identity changed from 0x"</span></div><div class="line">                    + Long.toHexString(ident) + <span class="string">" to 0x"</span></div><div class="line">                    + Long.toHexString(newIdent) + <span class="string">" while dispatching to "</span></div><div class="line">                    + msg.target.getClass().getName() + <span class="string">" "</span></div><div class="line">                    + msg.callback + <span class="string">" what="</span> + msg.what);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        msg.recycleUnchecked();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 loop() 方法中可以看到又一个 for 循环，循环每次都从 MessageQuene 中取出 Message，当取出的 Message 为空的时候就直接 return 掉，否则执行 <strong>msg.target.dispatchMessage(msg)</strong>（分发该消息，msg.target 是什么待会再说）。</p>
<h3 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h3><p>Handler 在发送消息的时候有许多种方法，大多都是要通过 sendMessageAtTime() 发送。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</div><div class="line">    MessageQueue queue = mQueue;</div><div class="line">    <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</div><div class="line">        RuntimeException e = <span class="keyword">new</span> RuntimeException(</div><div class="line">                <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</div><div class="line">        Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>enqueueMessage() 方法代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</div><div class="line">    msg.target = <span class="keyword">this</span>;</div><div class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;</div><div class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到 Message 正是在这个方法内被 Handler 装进了 MessageQuene。更让人激动的是我们发现了 msg.target = this 这行代码，这也就意味着在 Looper 的 loop() 方法中，msg.target.dispatchMessage(msg) 表示执行消息分发的是 Handler。我们再去 Handler 中搜索 dispatchMessage() 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</div><div class="line">        handleCallback(msg);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        handleMessage(msg);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>发现了我们熟悉的 handleMessage(msg) 方法，原来回调都是在这里。</p>
<p>至此，整个流程大致如下：</p>
<p><strong>Handler 执行发送消息的相关方法后，Message 被装进 MessageQuene 中。线程中的 Looper 则是在 loop() 方法内不断尝试从 MessageQuene 内取出 Message，然后调用与该 Message 绑定的 Handler（msg.target）对象的 dispatchMessage() 方法。最后可以看到处理消息的 handleMessage() 方法就是在 dispatchMessage() 方法内被调用的。</strong></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>在线程间通信中，子线程通过调用主线程的 Handler 的发送消息函数把子线程的 Message 发送到 MessageQuene 中。由于主线程默认调用了 Looper.loop() 方法，他会不断地去查询主线程的 MessageQuene 中是否有 Message 对象，如果有的话就把对象取出给主线程的 Handler 进行处理，从而达到了线程间通信。</li>
</ol>
<ol>
<li>一个线程可以有多个 Handler，但是一个线程只能对应一个 Looper 和一个 MessageQuene。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 源码分析 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android 中常见的内存泄漏总结]]></title>
      <url>/2018/01/31/Android-%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>在 Android 开发中，稍有不慎就容易引起内存泄漏，我们经常听到内存泄漏，但是什么是内存泄漏呢？</p>
<a id="more"></a>
<blockquote>
<p>内存泄漏：无用对象持续占用内存使得内存资源得不到及时释放，导致内存资源被浪费。</p>
</blockquote>
<p>可以看到内存泄漏是由于没有及时释放内存资源造成的，因此在不经意间我们就有可能造成了内存泄露。本文我们就来汇总下平时的编码过程中容易发生内存泄漏的地方并举例加以说明以及给出解决措施。</p>
<h4 id="1-集合类造成的内存泄露"><a href="#1-集合类造成的内存泄露" class="headerlink" title="1. 集合类造成的内存泄露"></a>1. 集合类造成的内存泄露</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Vector v = <span class="keyword">new</span> Vector(<span class="number">10</span>);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;<span class="number">100</span>; i++) &#123;</div><div class="line">	Object o = <span class="keyword">new</span> Object();</div><div class="line">	v.add(o);</div><div class="line">	o = <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这一例子是典型的集合类造成的泄漏。</p>
<p>这个例子中循环申请了 Object 对象，虽然最后将每个对象进行了释放，但是 Vector 依然持有该对象的引用，这对于 GC 来说是不能进行回收的。</p>
<p>所以，避免该方式的内存泄漏最简单的方法是将 Vector 置为空（v = null）</p>
<h4 id="2-单例造成的内存泄漏"><a href="#2-单例造成的内存泄漏" class="headerlink" title="2. 单例造成的内存泄漏"></a>2. 单例造成的内存泄漏</h4><p>单例模式在我们编写代码的过程中经常会用到，但是使用不慎也是极其容易引起内存泄漏。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppManager</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> AppManager instance;</div><div class="line">	<span class="keyword">private</span> Context context;</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="title">AppManager</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.context = context;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AppManager <span class="title">getInstance</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</div><div class="line">			instance = <span class="keyword">new</span> AppManager(context);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> instance;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这个例子是一个普通的单例模式，我们在创建的时候传入了 Context，但是对于传入的 Context 是非常有讲究的，一不小心就很可能造成内存泄漏。</p>
<ol>
<li>传入 Application 的 Context。因为 Application 的生命周期就是整个应用的生命周期，所以这不会有问题。</li>
<li>传入 Activity 的 Context。单传入的 Activity 要退出的时候，由于单例对象是静态的，其生命周期就是整个应用的生命周期，导致 Activity 在退出的时候单例对象一直持有 Activity 的引用使得 Activity 不能被回收，因而便造成了内存泄漏。</li>
</ol>
<p>避免内存泄漏的方式可以参考下面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">在应用的 Applicaiton 中添加一个静态方法</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Context <span class="title">getContext</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> getApplicationContext();</div><div class="line">&#125;</div><div class="line">*****************************************************************</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppManager</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> AppManager instance;</div><div class="line">	<span class="keyword">private</span> Context context;</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="title">AppManager</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.context = App.getContext();<span class="comment">// 使用Application 的context</span></div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AppManager <span class="title">getInstance</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</div><div class="line">			instance = <span class="keyword">new</span> AppManager(context);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> instance;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样创建的单例对象可直接调用 Application 的 Context，避免了内存泄漏。</p>
<h4 id="3-非静态内部类创建静态实例造成的内存泄漏"><a href="#3-非静态内部类创建静态实例造成的内存泄漏" class="headerlink" title="3. 非静态内部类创建静态实例造成的内存泄漏"></a>3. 非静态内部类创建静态实例造成的内存泄漏</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> TestResource mResource = <span class="keyword">null</span>;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">		setContentView(R.layout.activity_main);</div><div class="line">		<span class="keyword">if</span>(mManager == <span class="keyword">null</span>)&#123;</div><div class="line">		mManager = <span class="keyword">new</span> TestResource();</div><div class="line">		&#125;</div><div class="line">		<span class="comment">//...</span></div><div class="line">	&#125;</div><div class="line">  </div><div class="line">	<span class="class"><span class="keyword">class</span> <span class="title">TestResource</span> </span>&#123;</div><div class="line">  		<span class="comment">//...</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有时候某个 Activity 会被频繁启动，为了避免资源重复创建，就可能出现上面这种写法。</p>
<p>我们知道<strong>非静态内部类会默认持有外部类的引用</strong>。因此，这个 TestResource 会默认持有 MainActivity 的引用，而该非静态内部类又创建了一个静态实例，所以该实例的生命周期和应用一样长。如果我们要销毁这个 MainActivity，这个静态实例会持有 MainActivity 的引用，导致 MainActivity 的资源无法回收，造成了内存泄漏。</p>
<p>正确的做法是将该内部类设为静态内部类，这样静态内部类就不持有外部类的引用了，避免了内存泄漏。</p>
<h4 id="4-匿名内部类造成的内存泄漏"><a href="#4-匿名内部类造成的内存泄漏" class="headerlink" title="4. 匿名内部类造成的内存泄漏"></a>4. 匿名内部类造成的内存泄漏</h4><p>这种情况下造成的内存泄漏和上一种分析的状况有些类似，先看下面这一例子。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;  </div><div class="line">   </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;  </div><div class="line">      	<span class="keyword">super</span>.onCreate(savedInstanceState);  </div><div class="line">      	exampleOne();  </div><div class="line">    &#125;  </div><div class="line">   </div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exampleOne</span><span class="params">()</span> </span>&#123;  </div><div class="line">		<span class="keyword">new</span> Thread() &#123;<span class="comment">//匿名内部类，非静态的匿名类会持有外部类的一个隐式引用  </span></div><div class="line">			<span class="meta">@Override</span>  </div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </div><div class="line">				...</div><div class="line">			&#125;  </div><div class="line">		&#125;.start();  </div><div class="line">	&#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>非静态匿名内部类会默认持有外部类的引用</strong>（这和上一个例子中提到的非静态内部类会默认持有外部类的引用是一样的），因此这个新创建的线程会持有 MainActivity 的引用。而如果要销毁这个 Activity 之前，线程还在运行的话就会造成该线程持有 MainActivity 的引用，造成 MainActivity 的资源无法回收导致内存泄漏。</p>
<p>针对上述情况有两种解决方法。</p>
<ol>
<li>把非静态的线程匿名类定义成静态的内部类，这样静态的内部类就不会持有外部类的隐式引用。</li>
<li>在销毁 MainActivity 的 onDestroy() 方法中结束运行的线程。</li>
</ol>
<h4 id="5-Handler-造成的内存泄漏"><a href="#5-Handler-造成的内存泄漏" class="headerlink" title="5. Handler 造成的内存泄漏"></a>5. Handler 造成的内存泄漏</h4><p>我们为了避免发生 ANR 而不在主线程进行耗时操作经常要用到 Handler，但是使用的时候极有可能造成内存泄漏。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Handler handler = <span class="keyword">new</span> Handler() &#123;</div><div class="line">    	<span class="meta">@Override</span></div><div class="line">    	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">      	<span class="comment">// ...</span></div><div class="line">    	&#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">    	<span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">    	handler.postDelayed(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">      		<span class="meta">@Override</span></div><div class="line">      		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</div><div class="line">    	&#125;, <span class="number">1000</span> * <span class="number">60</span>);</div><div class="line"></div><div class="line">    finish();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>例子中在 MainActivity 中声明了一个延迟一分钟的 Message。当我们 finish() 掉 MainActivity 的时候，如果 MeassageQuene 里面还有 Message，那个延迟执行的 Message 会继续存在主线程中，它会持有 handler 的引用，而因为 handler 是非静态内部类，它默认持有 MainActivity 的隐式引用，从而造成了内存泄漏。</p>
<p>解决方法应该是把 handler 声明为静态，这样就不持有 MainActivity 的引用了。同时通过弱引用的方式引入 Activity，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line">  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">    	<span class="keyword">private</span> <span class="keyword">final</span> WeakReference&lt;MainActivity&gt; mActivity;</div><div class="line"></div><div class="line">    	<span class="function"><span class="keyword">public</span> <span class="title">MyHandler</span><span class="params">(SampleActivity activity)</span> </span>&#123;</div><div class="line">      		mActivity = <span class="keyword">new</span> WeakReference&lt;MainActivity&gt;(activity);</div><div class="line">    	&#125;</div><div class="line"></div><div class="line">    	<span class="meta">@Override</span></div><div class="line">   	 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">      		MainActivity activity = mActivity.get();</div><div class="line">      		<span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</div><div class="line">        		<span class="comment">// ...</span></div><div class="line">      		&#125;</div><div class="line">    	&#125;</div><div class="line">  	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> MyHandler handler = <span class="keyword">new</span> MyHandler(<span class="keyword">this</span>);</div><div class="line">  </div><div class="line">  	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Runnable mRunnable = <span class="keyword">new</span> Runnable() &#123;</div><div class="line">      <span class="meta">@Override</span></div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</div><div class="line">   &#125;;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">    	<span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">    	handler.postDelayed(mRunnable, <span class="number">1000</span> * <span class="number">60</span>);</div><div class="line"></div><div class="line">    finish();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里提到了 WeakReference，再贴个图了解下其他几种引用类型。</p>
<p><img src="https://camo.githubusercontent.com/068950c506eddc68677d6a84b5d7ffe1c03c6cf9/68747470733a2f2f67772e616c6963646e2e636f6d2f7470732f5442315536544e4c565858585863685846585858585858585858582d3634342d3534362e6a7067" alt="Java引用类型"></p>
<h4 id="6-资源未关闭造成的内存泄漏"><a href="#6-资源未关闭造成的内存泄漏" class="headerlink" title="6. 资源未关闭造成的内存泄漏"></a>6. 资源未关闭造成的内存泄漏</h4><p>这种类型的内存泄漏时最直接的。比如对于使用了 BraodcastReceiver，ContentObserver，File，游标 Cursor，Stream，Bitmap，监听器等资源，应该在 Activity 销毁之前及时关闭或者注销，否则就会导致资源不会被回收造成内存泄漏。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本文罗列了 Android 常见的几种内存泄漏情况，如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1. 集合类造成的内存泄漏</div><div class="line">2. 单例造成的内存泄漏</div><div class="line">3. 非静态内部类创建静态实例造成的内存泄漏</div><div class="line">4. 匿名内部类造成的内存泄漏</div><div class="line">5. Handler 造成的内存泄漏</div><div class="line">6. 资源未关闭造成的内存泄漏</div></pre></td></tr></table></figure>
<p>内存泄漏的发生场景可以为如下一句话：<strong>长生命周期的对象持有短生命周期对象的引用且该引用不能被回收。 </strong> </p>
<p>因此在写代码的时候要保持对<strong>生命周期</strong>的敏感，尤其注意单例、静态对象、全局性集合等的生命周期。</p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 内存泄漏 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android 免 key 定位组件]]></title>
      <url>/2018/01/25/Android-%E5%85%8D-key-%E5%AE%9A%E4%BD%8D%E7%BB%84%E4%BB%B6/</url>
      <content type="html"><![CDATA[<p>之前在项目中遇到了定位需求，便在高德地图定位 SDK 的基础上封装了一层运用在项目中。后来部门提出了组件化的思想，因此又整理完善了，于是便有了这套<a href="https://github.com/airxiao/LBS" target="_blank" rel="external">定位组件</a>。</p>
<a id="more"></a>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol>
<li>免key使用。无需去官网申请key，直接依赖后即可使用</li>
<li>支持多种坐标系。只需设置好坐标系，就可以返回该坐标系下对应的经纬度</li>
<li>使用简便。支持一次性定位，持续定位，无需考虑之间切换逻辑</li>
<li>定位信息全面，包含了经纬度、街道信息、错误码、以及当前的GPS状态等详细信息</li>
</ol>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>这套组件是在高德地图基础上进行封装的，其最大的特点就是免申请 key 便可使用。之所以有这样的需求是因为我司的 Android 开发划分为好几个组，每个组支撑不同的行业线，因此组内资源要做到尽可能的共享，提高开发效率。因此，这也是该组件要想达到共享必须做到免 key 申请的原因（github地址：<a href="https://github.com/airxiao/LBS）。" target="_blank" rel="external">https://github.com/airxiao/LBS）。</a></p>
<p>关于如何破解高德地图定位 SDK 免 key 使用我不再叙述，网上也可以搜到相关资料也有，我也是参考了各路大神的方案才破解成功的，顺便也感谢下各位大神。</p>
<p><strong>参考资料：</strong></p>
<blockquote>
<p><a href="https://juejin.im/entry/5805dc4f570c35006b7af21d" target="_blank" rel="external">Android 破解高德地图 sdk 使用 map 免 key</a></p>
<p><a href="http://caiyao.name/2016/09/10/%E7%A0%B4%E8%A7%A3%E9%AB%98%E5%BE%B7SDK%E5%AE%9E%E7%8E%B0%E5%85%8Dkey/" target="_blank" rel="external">破解高德SDK实现免key</a></p>
</blockquote>
<h3 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h3><p>使用该组件只需要在应用中依赖 Demo 中的 location_lbs 模块即可 ，之所以说该组件使用简便是因为对于开发者来说，该组件总共只有 7 个接口对外提供。</p>
<ol>
<li>定位初始化：app内调用一次即可<br>@param  context<br>@param  coorType要设置坐标系，包括火星坐标系，大地坐标系，百度坐标系（详情见文档）<br>initLocation(Context context, CoorType coorType)</li>
<li>初始化<br>unInitLocation()</li>
<li>持续获取位置信息<br>@param scanTime  设置定位间隔时间<br>@param callback  定位信息回调<br>startContinuesLoc(int scanTime, LocationCallBack callBack)</li>
<li>停止持续获取位置信息<br>@param callback 定位信息回调（与startContinuesLoc中的回调相同实例）<br>stopContinuesLoc(LocationCallBack callBack)</li>
<li>只获取一次位置信息<br>@param callback定位信息回调<br>startLocationOnce(LocationCallBack callBack)</li>
<li>设置定位模式<br>@param mode 有省电模式、设备模式、高精度模式可供选择（详情见文档）<br>setLocationMode(LocMode mode)</li>
<li>判断GPS是否可用<br>isGpsEnabled()</li>
</ol>
<p>其中，在 LocationCallBack 的回调接口中不要忘记对错误码进行判断，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> 	<span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">locationResult</span><span class="params">(LocationInfo locationInfo)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (locationInfo.getErrorCode() == LocationInfo.LOCATION_SUCCESS) &#123;</div><div class="line">          </div><div class="line">       &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p><a href="https://github.com/airxiao/LBS" target="_blank" rel="external">更多使用详情大家可以参考demo 和文档说明，地址：https://github.com/airxiao/LBS</a>。</p>
<p>如果你认为该组件对你有所帮助的，麻烦您帮忙点个 star，小弟在此谢过了。</p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 定位组件 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[浅谈 == 和 equals() 的区别]]></title>
      <url>/2018/01/21/%E6%B5%85%E8%B0%88%20==%20%E5%92%8C%20equals()%20%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<p>在日常编写代码的过程中，== 和 equals() 经常用到。记得我刚开始写代码的时候也是弄不懂两者要在什么情况下使用，这篇文章就总结下二者的区别。</p>
<a id="more"></a>
<h3 id=""><a href="#" class="headerlink" title="=="></a>==</h3><p>在 Java 中总共有 8 种基本类型（int，float，byte，double，long，short，char，boolean）。而 == 常用于比较这些基本类型的值是否相等。其实，== 比较的是基本类型的引用是否指向堆内存的同一块地址。</p>
<h3 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h3><p>equals() 是对象间的比较，它比较的是堆内存中的内容是否相同。在一些子类中，如 String、Integer 等，该方法将被重写。</p>
<h3 id="String-中-和equals-的比较"><a href="#String-中-和equals-的比较" class="headerlink" title="String 中 == 和equals() 的比较"></a>String 中 == 和equals() 的比较</h3><p>先看一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">String str1 = <span class="string">"airxiao"</span>;</div><div class="line">   String str2 = <span class="string">"airxiao"</span>;</div><div class="line">   </div><div class="line">   System.out.println(str1 == str2);</div><div class="line">   System.out.println(str1.equals(str2));</div><div class="line">   </div><div class="line">   String str2 = <span class="keyword">new</span> String(<span class="string">"airxiao"</span>);</div><div class="line">   System.out.println(str1 == str2);</div><div class="line">   System.out.println(str1.equals(str2));</div></pre></td></tr></table></figure>
<p>其输入的结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//以上代码输出结果</span></div><div class="line"><span class="keyword">true</span></div><div class="line"><span class="keyword">true</span></div><div class="line"><span class="keyword">false</span></div><div class="line"><span class="keyword">true</span></div></pre></td></tr></table></figure>
<p>可能有人对第一个输出的结果为 true 会有点疑惑，这里要先了解下 String  的一些特性。Java 的虚拟机会在内存中单独开辟一块区域用于存储字符串对象，我们称这块区域为字符串缓冲池。我们知道创建一个字符串对象有如下两种方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String a = <span class="string">"airxiao"</span>;  <span class="comment">// 方法1</span></div><div class="line">String a = <span class="keyword">new</span> String(<span class="string">"airxiao"</span>);  <span class="comment">// 方法2</span></div></pre></td></tr></table></figure>
<p>对于方法 1 来说，它会先去字符串缓冲池中查找是否已经有相同的对象，如果存在的话，那么会直接把这个对象的栈内存地址直接返回给 a，如果不存在的话对象会进入字符串缓冲池再把这个对象的栈内存地址赋予给 a。</p>
<p>对于方法 2 来说，它会直接告诉虚拟机在堆内存中生成一个新的 String 对象，但是并不会进入字符串缓冲池。</p>
<p>现在，也就不难理解第一个输出结果为何为 true 了。由于在创建 str1 的时候已经在字符创缓冲池内存储了 airxiao 对象，因此在创建 str2 的时候由于字符创缓冲池内查找到了 airxiao 对象，就直接把 str1 的栈内存地址给了 str2。因此 str1 和 str2 就拥有了相同的栈内存地址。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实，equals() 是属于 Object 类中的一个方法，在 Objects 类中，equals() 方法的实现是和 == 一样的。而 String 是属于封装类型，它在内部对 equals() 方法进行了重写，equals() 的结果主要取决于重写实现。如果我们自定义了一个对象，若要比较对象是否相同，也需要对 equals() 方法进行重写。</p>
<p>最后，对于 == 和equals() 的区别，简单概括为 == 比较的是基本类型的引用是否指向堆内存的同一块地址，equals() 比较的是堆内存中的内容是否相同。</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java 总结 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[如何获取Android系统挂载U盘的路径]]></title>
      <url>/2017/10/21/%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96Android%E7%B3%BB%E7%BB%9F%E6%8C%82%E8%BD%BDU%E7%9B%98%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
      <content type="html"><![CDATA[<p>最近项目开发中碰到这样一个需求：用户在定制的 Android 设备上插入 U 盘，然后在应用内导入 U 盘里的文件内容。</p>
<a id="more"></a>
<p>问题在于如何获取 U 盘的路径，网上搜索后大多数都是采用广播监听的方式来获取 U 盘的路径。但是如果 U 盘在设备开机之前就插着，这样登录应用后就获取不到 U 盘的路径了，于是乎此种方法作罢。</p>
<p>这时候伟大同事告诉了另外一种方法，就是从文件中读取路径。</p>
<p>U 盘在插入系统后，如果系统检测到 U盘，便会在系统的 <strong>proc</strong> 目录的 <strong>mounts</strong> 文件内产生一条记录。</p>
<p><img src="http://ovjvgviry.bkt.clouddn.com/17-10-21/62630543.jpg" alt=""></p>
<p>可以看到该文件记录了 U 盘每一次插入的相关信息（看不清楚？好吧，我摘取其中的一条用日志打印出来如下）。</p>
<p><img src="http://ovjvgviry.bkt.clouddn.com/17-10-21/17814426.jpg" alt=""></p>
<p>很长的一条信息，可能你看不懂（其实我也看不懂），没关系，找到对自己有用的信息即可。是不是发现了 <strong>/mnt/sdaq/sdaq1</strong> 这样一条信息，没错，他就是我们需要的 U 盘挂载的路径。我们只需要把 <strong>/proc/mounts</strong> 文件内的带 <strong>vfat</strong> 的最后一行找到，截取其中的 U 盘路径即可。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">searchPath</span><span class="params">()</span> </span>&#123;</div><div class="line">       String filePath = <span class="string">"/proc/mounts"</span>;</div><div class="line">       File file = <span class="keyword">new</span> File(filePath);</div><div class="line">       List&lt;String&gt; lineList = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">       InputStream inputStream =<span class="keyword">null</span>;</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           inputStream = <span class="keyword">new</span> FileInputStream(file);</div><div class="line">           <span class="keyword">if</span> (inputStream != <span class="keyword">null</span>) &#123;</div><div class="line">               InputStreamReader inputStreamReader = <span class="keyword">new</span> InputStreamReader(inputStream, <span class="string">"GBK"</span>);</div><div class="line">               BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(inputStreamReader);</div><div class="line">               String line = <span class="string">""</span>;</div><div class="line">               <span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="keyword">null</span>) &#123;</div><div class="line">                   <span class="keyword">if</span> (line.contains(<span class="string">"vfat"</span>)) &#123;</div><div class="line">                       lineList.add(line);</div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</div><div class="line">           e.printStackTrace();</div><div class="line">       &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">           e.printStackTrace();</div><div class="line">       &#125; <span class="keyword">finally</span> &#123;</div><div class="line">           <span class="keyword">if</span> (inputStream != <span class="keyword">null</span>) &#123;</div><div class="line">               <span class="keyword">try</span> &#123;</div><div class="line">                   inputStream.close();</div><div class="line">               &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                   e.printStackTrace();</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       String editPath = lineList.get(lineList.size() - <span class="number">1</span>);</div><div class="line">       <span class="keyword">int</span> start = editPath.indexOf(<span class="string">"/mnt"</span>);</div><div class="line">       <span class="keyword">int</span> end = editPath.indexOf(<span class="string">" vfat"</span>);</div><div class="line">       String path = editPath.substring(start, end);</div><div class="line">       Log.d(<span class="string">"SelectBusLineDialog"</span>, <span class="string">"path: "</span> + path);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>最后，可能有小伙伴会问「既然是定制的 Android 设备，第一次插入的时候不是知道了 U 盘的路径了吗，只要以后写死这个路径不就好了吗」。好吧，其实当时我也是这么想的，但是实际上每次插拔 U 盘，路径是不断变化的，而且仔细看上面那张大图可以发现每条记录的 U 盘挂载路径都是不同的，这也是不能写死路径的原因。（PS：十分感谢同事「开志哥」在项目中给予的帮助）</p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> U盘挂载 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android 手机存储那些事儿]]></title>
      <url>/2017/08/31/Android-%E6%89%8B%E6%9C%BA%E5%AD%98%E5%82%A8%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/</url>
      <content type="html"><![CDATA[<p>最近项目开发新增清除缓存需求，于是查阅相关资料并结合功能的实现过程，对手机存储的相关知识做下总结。</p>
<a id="more"></a>
<p>首先看下这张图：</p>
<p><img src="http://ovjvgviry.bkt.clouddn.com/17-8-31/87807963.jpg" alt=""></p>
<p>可以看到，我们把手机存储分为了内部存储和外部存储。</p>
<h3 id="1-内部存储"><a href="#1-内部存储" class="headerlink" title="1. 内部存储"></a>1. 内部存储</h3><p>内部存储指的是存储在手机 /data/data/&lt;应用包名&gt; 目录下的数据，附上一张高清无码大图。</p>
<p><img src="http://ovjvgviry.bkt.clouddn.com/17-8-31/48236743.jpg" alt=""></p>
<p>从图中可以看到（注意：手机没 ROOT 是无法打开该文件夹的），内部存储有以下几种我们熟悉的数据：</p>
<p>files——文件存储（注：其对应路径 /data/data/&lt;应用包名&gt;/files 可通过 context.getFilesDir() 获取）</p>
<p>shared_prefs——sharedPreference 存储</p>
<p>cache——图片缓存（注：其对应路径 /data/data/&lt;应用包名&gt;/cache 可通过 context.getCacheDir() 获取，由于我的项目中用到了 Glide，所以发现 Glide 的图片存在了该目录下的 image_manager_disk_chache 文件夹内）</p>
<p>databases——数据库存储</p>
<h3 id="2-外部存储"><a href="#2-外部存储" class="headerlink" title="2. 外部存储"></a>2. 外部存储</h3><p>外部存储分为内置 SD 卡存储和拓展卡存储（外置 SD 卡）。</p>
<ul>
<li>内置 SD 卡：现在出产的手机基本都自带的，也就是我们常说的存储空间，有 16G，32G，64G，128G（以前的部分老旧低端机没有内置 SD 卡）</li>
<li>外置 SD 卡：可以插入手机的存储卡，扩大手机存储内存</li>
</ul>
<p>特别注意下，一般我们在新建文件夹的时候需要判断一下手机是否有 SD 卡，代码如下（项目中碰到的坑）:</p>
<p><code>Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)</code></p>
<p>对于 SD 卡的路径 /storage/sdcard，我们可以通过 Enviroment 中的方法获取到。</p>
<p><code>Environment.getExternalStorageDirectory()</code></p>
<p>SD 卡的文件路径也可以分为公有路径和私有路径。</p>
<h4 id="2-1-公有路径"><a href="#2-1-公有路径" class="headerlink" title="2.1 公有路径"></a>2.1 公有路径</h4><p>公有路径的获取方式如下：</p>
<p><code>Environment.getExternalStoragePublicDirectory(String type)</code></p>
<p>其参数共有 10 种类型，对应的参数和路径如下表：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>路径</th>
</tr>
</thead>
<tbody>
<tr>
<td>Environment.DIRECTORY_MUSIC</td>
<td>/storage/sdcard0/Music</td>
</tr>
<tr>
<td>DIRECTORY_PODCASTS</td>
<td>/storage/sdcard0/Podcasts</td>
</tr>
<tr>
<td>DIRECTORY_RINGTONES</td>
<td>/storage/sdcard0/Ringtones</td>
</tr>
<tr>
<td>DIRECTORY_ALARMS</td>
<td>/storage/sdcard0/Alarms</td>
</tr>
<tr>
<td>DIRECTORY_NOTIFICATIONS</td>
<td>/storage/sdcard0/Notifications</td>
</tr>
<tr>
<td>DIRECTORY_PICTURES</td>
<td>/storage/sdcard0/Pictures</td>
</tr>
<tr>
<td>DIRECTORY_MOVIES</td>
<td>/storage/sdcard0/Movies</td>
</tr>
<tr>
<td>DIRECTORY_DOWNLOADS</td>
<td>/storage/sdcard0/Download</td>
</tr>
<tr>
<td>DIRECTORY_DCIM</td>
<td>/storage/sdcard0/DCIM</td>
</tr>
<tr>
<td>DIRECTORY_DOCUMENTS</td>
<td>/storage/sdcard0/Documents</td>
</tr>
</tbody>
</table>
<h4 id="2-2-私有目录"><a href="#2-2-私有目录" class="headerlink" title="2.2 私有目录"></a>2.2 私有目录</h4><p>在 SD 卡目录下的 Android 文件夹就是对应的私有目录。打开 Android 目录，可以看到里面还有 data 文件夹，再打开这个文件夹，就是许多应用包名组成的文件夹。可以发现这些包名文件夹里面基本都包含有 files 和 cache 这两个文件夹。这两个文件夹的路径可以通过如下方法获取：</p>
<p>files——sdcard/Android/data/应用包名/files（注：可通过 context.getExternalFilesDir() 获取）</p>
<p>cache——sdcard/Android/data/应用包名/cache（注：可通过 context.getExternalCacheDir() 获取）</p>
<p>当调用 getExternalFilesDir() 和 getExternalCacheDir() 即可创建 files 和 cache 文件夹。看到这，你或许会问：</p>
<blockquote>
<p>这两个文件夹不是和我们上面看到的内部存储一样吗，为什么要存在这里面呢。</p>
</blockquote>
<p>原因在于内部存储空间有限，我们一般都是操作外部存储空间，虽然我们可以获得内部存储的路径，但是我们基本不会去操作内部空间，何况在没有 ROOT 情况下，也没法进行操作。而且 Google 官方也建议我们在外部存储的私有目录下进行数据存储操作。</p>
<p>这是或许你又会问：</p>
<blockquote>
<p>很多 APP 都是在 SD 卡目录下创建文件进行数据存储操作的。</p>
</blockquote>
<p>的确，很多 APP 是这么干的，但是当用户卸载 APP 的时候，<strong>内部存储</strong>中的包名文件夹及相关数据会被删除，<strong>外部存储</strong>的私有目录下相关数据也会跟随包名文件夹一起被删除，但是自己创建的文件夹是不会被删除的。在 sdcard 目录下创建文件不仅不利于系统维护，也会造成用户的反感（反正我是会经常去删除 SD 卡目录下的空文件夹）。</p>
<p>这时候我们再回到清除缓存这个功能上。对于需要被清除的数据，应该是内部存储中<strong>相应的 files</strong> 和 cache 文件夹内的数据和外部存储私有目录下<strong>相应的 files</strong> 和 cache 文件夹内的数据（可根据需求清除 files 文件夹内的相应数据）。</p>
<p>最后附上一个清除缓存数据的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CleanCacheManager</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * <span class="doctag">@param</span> context</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     * <span class="doctag">@throws</span> Exception</div><div class="line">     *             获取当前缓存</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getTotalCacheSize</span><span class="params">(Context context)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">long</span> cacheSize = getFolderSize(context.getCacheDir());</div><div class="line">        <span class="keyword">if</span> (Environment.getExternalStorageState().equals(</div><div class="line">                Environment.MEDIA_MOUNTED)) &#123;</div><div class="line">            cacheSize += getFolderSize(context.getExternalCacheDir());</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> getFormatSize(cacheSize);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * <span class="doctag">@param</span> context</div><div class="line">     *            删除缓存</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clearAllCache</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">        deleteDir(context.getCacheDir());</div><div class="line">        <span class="keyword">if</span> (Environment.getExternalStorageState().equals(</div><div class="line">                Environment.MEDIA_MOUNTED)) &#123;</div><div class="line">            deleteDir(context.getExternalCacheDir());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">deleteDir</span><span class="params">(File dir)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (dir != <span class="keyword">null</span> &amp;&amp; dir.isDirectory()) &#123;</div><div class="line">            String[] children = dir.list();</div><div class="line">            <span class="keyword">int</span> size = <span class="number">0</span>;</div><div class="line">            <span class="keyword">if</span> (children != <span class="keyword">null</span>) &#123;</div><div class="line">                size = children.length;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">                    <span class="keyword">boolean</span> success = deleteDir(<span class="keyword">new</span> File(dir, children[i]));</div><div class="line">                    <span class="keyword">if</span> (!success) &#123;</div><div class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (dir == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">            <span class="keyword">return</span> dir.delete();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 获取文件</span></div><div class="line">    <span class="comment">// Context.getExternalFilesDir() --&gt; SDCard/Android/data/你的应用的包名/files/</span></div><div class="line">    <span class="comment">// 目录，一般放一些长时间保存的数据</span></div><div class="line">    <span class="comment">// Context.getExternalCacheDir() --&gt;</span></div><div class="line">    <span class="comment">// SDCard/Android/data/你的应用包名/cache/目录，一般存放临时缓存数据</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getFolderSize</span><span class="params">(File file)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">long</span> size = <span class="number">0</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            File[] fileList = file.listFiles();</div><div class="line">            <span class="keyword">int</span> size2 = <span class="number">0</span>;</div><div class="line">            <span class="keyword">if</span> (fileList != <span class="keyword">null</span>) &#123;</div><div class="line">                size2 = fileList.length;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size2; i++) &#123;</div><div class="line">                    <span class="comment">// 如果下面还有文件</span></div><div class="line">                    <span class="keyword">if</span> (fileList[i].isDirectory()) &#123;</div><div class="line">                        size = size + getFolderSize(fileList[i]);</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        size = size + fileList[i].length();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> size;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 格式化单位</div><div class="line">     * 计算缓存的大小</div><div class="line">     * <span class="doctag">@param</span> size</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getFormatSize</span><span class="params">(<span class="keyword">double</span> size)</span> </span>&#123;</div><div class="line">        <span class="keyword">double</span> kiloByte = size / <span class="number">1024</span>;</div><div class="line">        <span class="keyword">if</span> (kiloByte &lt; <span class="number">1</span>) &#123;</div><div class="line">            <span class="comment">// return size + "Byte";</span></div><div class="line">            <span class="keyword">return</span> <span class="string">"0KB"</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">double</span> megaByte = kiloByte / <span class="number">1024</span>;</div><div class="line">        <span class="keyword">if</span> (megaByte &lt; <span class="number">1</span>) &#123;</div><div class="line">            BigDecimal result1 = <span class="keyword">new</span> BigDecimal(Double.toString(kiloByte));</div><div class="line">            <span class="keyword">return</span> result1.setScale(<span class="number">2</span>, BigDecimal.ROUND_HALF_UP)</div><div class="line">                    .toPlainString() + <span class="string">"KB"</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">double</span> gigaByte = megaByte / <span class="number">1024</span>;</div><div class="line">        <span class="keyword">if</span> (gigaByte &lt; <span class="number">1</span>) &#123;</div><div class="line">            BigDecimal result2 = <span class="keyword">new</span> BigDecimal(Double.toString(megaByte));</div><div class="line">            <span class="keyword">return</span> result2.setScale(<span class="number">2</span>, BigDecimal.ROUND_HALF_UP)</div><div class="line">                    .toPlainString() + <span class="string">"MB"</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">double</span> teraBytes = gigaByte / <span class="number">1024</span>;</div><div class="line">        <span class="keyword">if</span> (teraBytes &lt; <span class="number">1</span>) &#123;</div><div class="line">            BigDecimal result3 = <span class="keyword">new</span> BigDecimal(Double.toString(gigaByte));</div><div class="line">            <span class="keyword">return</span> result3.setScale(<span class="number">2</span>, BigDecimal.ROUND_HALF_UP)</div><div class="line">                    .toPlainString() + <span class="string">"GB"</span>;</div><div class="line">        &#125;</div><div class="line">        BigDecimal result4 = <span class="keyword">new</span> BigDecimal(teraBytes);</div><div class="line">        <span class="keyword">return</span> result4.setScale(<span class="number">2</span>, BigDecimal.ROUND_HALF_UP).toPlainString()</div><div class="line">                + <span class="string">"TB"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 存储 </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[手机抓包教程]]></title>
      <url>/2017/06/25/%E6%89%8B%E6%9C%BA%E6%8A%93%E5%8C%85%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>Android 开发中经常需要通过抓包来解决一些问题，今天就来讲下 Android 手机的抓包过程。</p>
<a id="more"></a>
<h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>手机抓包肯定需要手机啦，不过必须是 Root 过的手机，否则无法抓包，手机 Root 过程不再赘述，随便下载一个「ROOT 大师」之类的软件便可 Root 成功。除此之外必须要下载 <a href="https://pan.baidu.com/s/1o8LTZOu" target="_blank" rel="external">tcpdump</a>。工具都准备好了，接下来就可以开始 tcpdump 安装过程了。</p>
<h3 id="tcpdump-安装过程"><a href="#tcpdump-安装过程" class="headerlink" title="tcpdump 安装过程"></a>tcpdump 安装过程</h3><h4 id="1、安装-tcpdump"><a href="#1、安装-tcpdump" class="headerlink" title="1、安装 tcpdump"></a>1、安装 tcpdump</h4><p>通过 adb 命令把下载来的 tcpdump 导入手机。具体的 adb 命令如下：</p>
<ul>
<li>adb shell</li>
<li>su</li>
<li>chmod 777 /data/local – 给 /data/local 路径赋予访问权限</li>
</ul>
<p>接下来重新打开终端，把 tcpdump 复制进  /data/local 目录下，命令如下：</p>
<ul>
<li>adb push <strong>/Users/xiaoyunlou/抓包教程/tcpdump</strong> /data/local —注意粗体部分为 tcpdump 在电脑中的路径，只要把 tcpdump 拖进终端即可显示</li>
</ul>
<h4 id="2、给-tcpdump-赋予权限"><a href="#2、给-tcpdump-赋予权限" class="headerlink" title="2、给 tcpdump 赋予权限"></a>2、给 tcpdump 赋予权限</h4><p>重新打开终端，依次输入如下命令：</p>
<ul>
<li>adb shell</li>
<li>su</li>
<li>chmod 777 /data/local/tcpdump – 此步骤便是给 tcpdump 赋予权限</li>
</ul>
<p>至此，抓包前的准备都已完成，只要手机成功安装了 tcpdump 就可以开始抓包的操作了。</p>
<h3 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h3><p>重新打开终端，输入如下命令：</p>
<ul>
<li>adb shell</li>
<li>su</li>
<li>/data/local/tcpdump -p -s 0 -w /sdcard/6.pcap – 6.pcap就是抓到的包 </li>
</ul>
<p>这时候，如果终端显示</p>
<p><img src="https://ooo.0o0.ooo/2017/06/25/594fd9f07e3f4.png" alt="屏幕快照 2017-06-25 22.57.51"></p>
<p>则表示正在抓包，当做完网络相关操作便可在终端执行 ctrl + c 结束抓包。这时候你会在手机的根目录下看到一个 6.pcap 的文件，这便是我们抓到的包，最后执行下列命令即可把抓到的包复制到电脑上。</p>
<ul>
<li>adb pull /sdcard/6.pcap</li>
</ul>
<p>这时候我们就可以在电脑上通过 wireshark 之类的抓包分析工具对抓到的包进行分析了。</p>
]]></content>
      
        <categories>
            
            <category> 教程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 抓包 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[最新 MAC 上基于 Github + Hexo 博客搭建教程]]></title>
      <url>/2017/05/20/%E6%9C%80%E6%96%B0%20MAC%20%E4%B8%8A%E5%9F%BA%E4%BA%8E%20Github%20+%20Hexo%20%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>折腾了大半天的时间终于搭建好了自己的博客。在网上随便一搜就有一大堆搭建博客的教程，那为什么还要再写一遍呢。原因如下：</p>
<a id="more"></a>
<ul>
<li>网上绝大多数教程是基于 Windows 系统搭建的博客，在苹果系统上搭建博客的教程不多。</li>
<li>记录搭建博客过程中踩过的坑，帮助更多的小伙伴。 </li>
</ul>
<p>言归正传，接下来进入博客的搭建过程。</p>
<h3 id="1-Node-js-下载和安装"><a href="#1-Node-js-下载和安装" class="headerlink" title="1. Node.js 下载和安装"></a>1. Node.js 下载和安装</h3><p>下载地址：<a href="https://nodejs.org/en/download/" target="_blank" rel="external">Node.js 下载地址</a></p>
<h3 id="2-Git-的下载和安装"><a href="#2-Git-的下载和安装" class="headerlink" title="2. Git 的下载和安装"></a>2. Git 的下载和安装</h3><p>下载地址：<a href="https://git-scm.com/download/" target="_blank" rel="external">Git 下载地址</a></p>
<h3 id="3-Hexo-安装（重点）"><a href="#3-Hexo-安装（重点）" class="headerlink" title="3. Hexo 安装（重点）"></a>3. Hexo 安装（重点）</h3><ul>
<li><p>打开苹果电脑终端</p>
</li>
<li><p>输入安装命令 </p>
<p><code>$ sudo npm install -g hexo-cli</code></p>
</li>
<li><p>输入检验是否安装成功命令</p>
<p><code>$ hexo -v</code></p>
<p>若安装成功，会出现如下信息：</p>
<p><img src="http://i4.buimg.com/588926/a4a7f68b964afd96.jpg" alt=""></p>
</li>
<li><p>在 Mac 的 User 目录下新建文件夹，取名 Hexo</p>
</li>
<li><p>输入下面的命令，进入到 Hexo 目录下</p>
<p><code>$ cd Hexo/</code></p>
</li>
<li><p>输入下面命令，随后会在 Hexo 文件夹下简历网站所需要的所有文件</p>
<p><code>$ hexo init</code></p>
</li>
<li><p>现在，一个本地博客已经搭建成功，可以分别输入以下命令进行验证：</p>
<p><code>$ hexo g</code> –生成</p>
<p><code>$ hexo s</code> –启动服务本地预览</p>
<p>服务开启成功后到浏览器中输入 localhost:4000，这时候一个博客便映入眼帘。通过在终端输入Ctrl + C 可以停止本地预览</p>
</li>
</ul>
<h3 id="4-Github-Pages-设置"><a href="#4-Github-Pages-设置" class="headerlink" title="4. Github Pages 设置"></a>4. Github Pages 设置</h3><p>该部分可参考博客 <a href="https://adsuper.github.io/2017/03/19/%E5%9F%BA%E4%BA%8EHexo-Github-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AC%94%E8%AE%B0-1/" target="_blank" rel="external">珞璃之神-基于Hexo-Github—搭建个人博客笔记</a> 的第三部分「github Pages设置」</p>
<h3 id="5-更换博客主题"><a href="#5-更换博客主题" class="headerlink" title="5.  更换博客主题"></a>5.  更换博客主题</h3><p>在第 2 部分预览的时候，默认加载的主题是「landscape」。不过个人感觉「next」主题似乎更好看。</p>
<p><img src="http://i2.muimg.com/588926/9af6bd168a6db7c0.jpg" alt=""></p>
<p>自个体会下。</p>
<p>具体更换主题步骤如下：</p>
<ul>
<li><p>复制主题，在终端输入以下命令</p>
<p><code>$ git clone https://github.com/iissnan/hexo-theme-next themes/next</code></p>
</li>
<li><p>配置 Hexo 目录下的 config.yml 配置文件中的 theme 属性，将其设置为 next</p>
</li>
<li><p>启用 next 主题</p>
<p><code>$ cd themes/next</code> –在终端上从 Hexo 根目录进入你复制的主题目录</p>
<p><code>$ git pull</code></p>
<p><code>$ hexo clean</code> –清除默认的缓存主题</p>
<p><code>$ hexo g</code> –生成</p>
<p><code>$ hexo s</code> –启动本地预览</p>
</li>
<li><p>到浏览器中输入 localhost:4000 查看 next 主题是否更换成功</p>
</li>
</ul>
<p>至此，基于Github + Hexo 的博客也已经搭建成功！</p>
<h3 id="6-一键发布博客"><a href="#6-一键发布博客" class="headerlink" title="6. 一键发布博客"></a>6. 一键发布博客</h3><p>接下来，教大家一键部署博客到 Github 的方法。</p>
<p>此部分完全参考博客 <a href="https://smartbeng.github.io/2017/03/26/blogFinish/" target="_blank" rel="external">smartbeng-最适合新手的 GitHub + Hexo 「大话」博客搭建教程</a> ，内容如下：</p>
<ol>
<li><p>进入 Hexo 的根目录 接着操作以下命令</p>
<p><code>$ cd Hexo</code></p>
<p>注意 1：现在我们需要clone我们自己的GitHub仓库了</p>
<p>注意 3：切记下面是<strong>你自己的仓库名</strong> , 把名字都改过来 , 下面我用的是我的仓库名字</p>
<p><code>$ git clone https://github.com/storm/</code></p>
<p><code>strom.github.io.git .deploy/storm.github.io</code></p>
<p>翻译下这条命令的意思</p>
<p>将我们之前创建的GitHub 仓库克隆到本地 , 命令会新建一个目录叫做.deploy用于存放克隆的代码。</p>
<p>然后会在.deploy文件夹下生成一个 <strong>你的名字.github.io</strong> 的文件夹用于存放文件</p>
</li>
<li><p>接着在 Hexo <strong>根目录</strong>下创建一个 .txt 文件 , 把下面的命令复制进去</p>
</li>
<li><p>注意 ：<strong>你的GitHub名字</strong>是什么就<strong>把你的名字全部改到下面</strong> , 细心点（下面加粗的部分就是待修改的地方）</p>
<p>hexo generate</p>
<p>cp -R public/<em> .deploy/<em>*jacman</em></em>.github.io</p>
<p>cd .deploy/<strong>jacman</strong>.github.io</p>
<p>git add .</p>
<p>git commit -m “update”</p>
<p>git push origin master</p>
</li>
<li><p>将这个 <strong>.txt 文件的后缀改成 .sh</strong> , 它就变成了脚本文件 , 我们就将文件改成 <strong>deploy.sh</strong> 吧！意思就是部署</p>
</li>
<li><p>从此以后需要部署本地博客到 GitHub , 直接把脚本拖入到终端运行即可。</p>
</li>
</ol>
<p>该部分需要注意的事项：</p>
<ol>
<li>脚本拖入终端运行时一定要切换到 Hexo 目录下</li>
<li>运行如显示 Permission denied 说明没有权限，此时需要对脚本进行赋予权限的操作：在终端输入chmod 777，接着拖入脚本，再按回车，权限赋予成功后再把脚本拖入终端运行即可（运行脚本一定要切换到 Hexo目录下）。</li>
</ol>
<h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h3><p>搭建博客过程中会踩到许多坑，其中很多问题都是由于没有切换到 Hexo 目录下造成的。若能在终端上切换到正确的目录下进行操作，搭建博客的过程也会顺利不少。</p>
]]></content>
      
        <categories>
            
            <category> Hexo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
