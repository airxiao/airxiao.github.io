<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[复杂度分析（上）]]></title>
      <url>/2018/09/26/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>复杂度分析是整个算法学习的精髓，只要掌握了它，数据结构和算法的内容基本上就掌握了一半。</p>
<a id="more"></a>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>时间复杂度的全称是渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系。</p>
<h5 id="大-O-复杂度表示法"><a href="#大-O-复杂度表示法" class="headerlink" title="大 O 复杂度表示法"></a>大 O 复杂度表示法</h5><p><img src="https://static001.geekbang.org/resource/image/22/ef/22900968aa2b190072c985a08b0e92ef.png" alt="大 O 复杂度表示法"></p>
<p>其中，T(n)表示代码执行的时间；n 表示数据规模的大小；f(n) 表示每行代码执行的次数总和。因为这是一个公式，所以用 f(n) 来表示。公式中的 O，表示代码的执行时间 T(n) 与 f(n) 表达式成正比。</p>
<p>大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度，简称时间复杂度。</p>
<p>当 n 很大时，公式中的低阶、常量、系数三部分并不左右增长趋势，所以都可以忽略。我们只需要记录一个最大量级就可以了。也就是说：总的时间复杂度就等于量级最大的那段代码的时间复杂度。</p>
<h5 id="几种常见时间复杂度实例分析"><a href="#几种常见时间复杂度实例分析" class="headerlink" title="几种常见时间复杂度实例分析"></a>几种常见时间复杂度实例分析</h5><p><img src="https://static001.geekbang.org/resource/image/37/0a/3723793cc5c810e9d5b06bc95325bf0a.jpg" alt="几种常见时间复杂度实例分析"></p>
<p>图中的复杂度量级，可以分为多项式量级和非多项式量级。其中，非多项式量级只有两个：O(2n) 和 O(n!)。</p>
<p>当数据规模 n 越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长。所以，非多项式时间复杂度的算法其实是非常低效的算法。而几种常见的多项式时间复杂度如下：</p>
<ol>
<li><p>O(1)</p>
<p>O(1) 只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span> <span class="keyword">int</span> i = <span class="number">8</span>;</div><div class="line"><span class="number">2</span> <span class="keyword">int</span> j = <span class="number">6</span>;</div><div class="line"><span class="number">3</span> <span class="keyword">int</span> sum = i + j;</div></pre></td></tr></table></figure>
<p>一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。</p>
</li>
</ol>
<ol>
<li><p>O(logn)、O(nlogn)</p>
<p>对数阶时间复杂度非常常见，同时也是最难分析的一种时间复杂度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span> i=<span class="number">1</span>;</div><div class="line"><span class="number">2</span> <span class="keyword">while</span> (i &lt;= n)  &#123;</div><div class="line"><span class="number">3</span>   i = i * <span class="number">2</span>;</div><div class="line"><span class="number">4</span> &#125;</div></pre></td></tr></table></figure>
<p>从代码中可以看出，变量 i 的值从 1 开始取，每循环一次就乘以 2。当大于 n 时，循环结束。如果把它一个一个列出来，就应该是这个样子的：</p>
<p><img src="https://static001.geekbang.org/resource/image/9b/9a/9b1c88264e7a1a20b5954be9bc4bec9a.jpg" alt=""></p>
<p>所以，我们只要知道 x 值是多少，就知道这行代码执行的次数了。x=log2n，所以，这段代码的时间复杂度就是 O(log2n)。</p>
<p>在采用大 O 标记复杂度的时候，可以忽略系数，即 O(Cf(n)) = O(f(n))。因此，在对数阶时间复杂度的表示方法里，我们忽略对数的“底”，统一表示为 O(logn)。</p>
</li>
<li><p>O(m+n)、O(m*n)</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> sum_1 = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> i = <span class="number">1</span>;</div><div class="line">  <span class="keyword">for</span> (; i &lt; m; ++i) &#123;</div><div class="line">    sum_1 = sum_1 + i;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">int</span> sum_2 = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> j = <span class="number">1</span>;</div><div class="line">  <span class="keyword">for</span> (; j &lt; n; ++j) &#123;</div><div class="line">    sum_2 = sum_2 + j;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> sum_1 + sum_2;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从代码中可以看出，m 和 n 是表示两个数据规模。我们无法事先评估 m 和 n 谁的量级大，所以我们在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。所以，上面代码的时间复杂度就是 O(m+n)。</p>
</li>
</ol>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>空间复杂度全称就是渐进空间复杂度，表示算法的存储空间与数据规模之间的增长关系。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span> <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line"><span class="number">2</span>  <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line"><span class="number">3</span>  <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[n];</div><div class="line"><span class="number">4</span>  <span class="keyword">for</span> (i; i &lt;n; ++i) &#123;</div><div class="line"><span class="number">5</span>    a[i] = i * i;</div><div class="line"><span class="number">6</span>  &#125;</div><div class="line"></div><div class="line"><span class="number">7</span>  <span class="keyword">for</span> (i = n-<span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</div><div class="line"><span class="number">8</span>    print out a[i]</div><div class="line"><span class="number">9</span>  &#125;</div><div class="line"><span class="number">10</span>&#125;</div></pre></td></tr></table></figure>
<p>可以看到，第 2 行代码中，我们申请了一个空间存储变量 i，但是它是常量阶的，跟数据规模 n 没有关系，所以我们可以忽略。第 3 行申请了一个大小为 n 的 int 类型数组，除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是 O(n)。</p>
<p>我们常见的空间复杂度就是 O(1)、O(n)、O(n2 )，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率与数据规模之间的增长关系，可以粗略地表示，越高阶复杂度的算法，执行效率越低。</p>
<p><img src="https://static001.geekbang.org/resource/image/49/04/497a3f120b7debee07dc0d03984faf04.jpg" alt=""></p>
<p>常见的复杂度并不多，从低阶到高阶有：O(1)、O(logn)、O(n)、O(nlogn)、O(n2 )。对于绝大多数数据结构和算法来说，其复杂度无外乎这几个。</p>
]]></content>
      
        <categories>
            
            <category> 数据结构和算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数据结构和算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[视频硬解码]]></title>
      <url>/2018/08/12/%E8%A7%86%E9%A2%91%E7%A1%AC%E8%A7%A3%E7%A0%81/</url>
      <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>实时视频在播放的时候出现卡顿和延迟现象，经分析是因为视频在 C 层采用的是软解码的方式进行播放，因此决定在 Java 层改用硬解码方式。</p>
<a id="more"></a>
<h3 id="软解码和硬解码区别"><a href="#软解码和硬解码区别" class="headerlink" title="软解码和硬解码区别"></a>软解码和硬解码区别</h3><ul>
<li>软解码：使用 CPU 进行编码，实现直接、简单，参数调整方便，升级易，但 CPU 负载重，性能较硬编码低。</li>
<li>硬解码：使用显卡 GPU、专用的 DSP、FPGA、ASIC 芯片等方式进行编码，性能高。</li>
</ul>
<p>可见使用硬解码的方式能降低 CPU 的负载，使得视频能播放得更加流畅。</p>
<h3 id="硬解码实现"><a href="#硬解码实现" class="headerlink" title="硬解码实现"></a>硬解码实现</h3><h4 id="1-初始化解码器"><a href="#1-初始化解码器" class="headerlink" title="1.初始化解码器"></a>1.初始化解码器</h4><p>视频的硬解码主要用到了 MediaCodec 类，对于开发者来说只要把 H.264 标准的码流通过这个类进行解码就可以得到 YUV 格式的视频了，而解码过程也是 Android 都已经封装好了，所以使用起来十分方便。本人也对硬解部分做了封装，有需要的小伙伴也可以直接拿去使用（<a href="https://github.com/airxiao/MediaDecoder" target="_blank" rel="external">Github传送门</a>）。以下的讲解也是基于我封装的基础上进行讲解的。</p>
<p>对于使用视频硬解，可以在 SurfaceView 的 surfaceCreated 回调里面对 MediaCodec 进行初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> MediaCodecDecoder <span class="title">createNewDecoder</span><span class="params">(SurfaceHolder holder)</span> </span>&#123;</div><div class="line">    VDConfig vdConfig = <span class="keyword">new</span> VDConfig();</div><div class="line">    vdConfig.setFramerate(DEFAULT_RATE);</div><div class="line">    vdConfig.setHeight(holder.getSurfaceFrame().height());</div><div class="line">    vdConfig.setWidth(holder.getSurfaceFrame().width());</div><div class="line">    vdConfig.setDisplay(holder);</div><div class="line">    MediaCodecDecoder mediaCodecDecoder = <span class="keyword">new</span> MediaCodecDecoder();</div><div class="line">    mediaCodecDecoder.setConfig(vdConfig);</div><div class="line">    mediaCodecDecoder.start();</div><div class="line">    <span class="keyword">return</span> mediaCodecDecoder;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>初始化的过程主要是创建一个新的 MediaCodec，而在我封装的 MediaCodecDecoder 里面主要是新建了一个进行解码的线程和一个存储视频帧的队列。通过调用 mediaCodecDecoder.start() 就完成了初始化的过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mIsStart) &#123;</div><div class="line">        Log.w(TAG, <span class="string">"is already start"</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (mVDConfig == <span class="keyword">null</span>) &#123;</div><div class="line">        Log.e(TAG, <span class="string">"start without decode config"</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    initMediaCodec();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">initMediaCodec</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mIsStart) &#123;</div><div class="line">       <span class="keyword">return</span>; </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        mMediaCodec = MediaCodec.createDecoderByType(MIME_TYPE);</div><div class="line">        MediaFormat format = MediaFormat.createVideoFormat(MIME_TYPE,        mVDConfig.getWidth(), mVDConfig.getHeight());</div><div class="line">        mMediaCodec.configure(format, mVDConfig.getDisplay().getSurface(), <span class="keyword">null</span>, <span class="number">0</span>);</div><div class="line">        mMediaCodec.start();</div><div class="line">        mIsStart = <span class="keyword">true</span>;</div><div class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">        Log.e(TAG, <span class="string">"initMediaCodec Exception"</span> + e.getMessage());</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到在初始化主要是设置了一些基本信息，比如要解码的码流类型，视频帧的宽高以及设置解码完后要进行播放的 SurfaveView 控件。</p>
<h4 id="2-解码"><a href="#2-解码" class="headerlink" title="2.解码"></a>2.解码</h4><p>初始化完成后就可以进行解码操作了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * H.264码流回调</div><div class="line"> * <span class="doctag">@param</span> index 窗口序号</div><div class="line"> * <span class="doctag">@param</span> data 码流</div><div class="line"> * <span class="doctag">@param</span> len 码流长度</div><div class="line"> * <span class="doctag">@param</span> rate 帧率</div><div class="line"> * <span class="doctag">@param</span> timestamp 时间戳</div><div class="line"> * <span class="doctag">@param</span> width 视频宽度</div><div class="line"> * <span class="doctag">@param</span> height 视频高度</div><div class="line"> * <span class="doctag">@param</span> subType 视频帧类型(I P B)</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onVideoDataCallback</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">byte</span>[] data, <span class="keyword">int</span> len, <span class="keyword">int</span> rate, <span class="keyword">long</span> timestamp, <span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="keyword">int</span> subType)</span> </span>&#123;</div><div class="line">    Log.d(<span class="string">"EventManager"</span>, <span class="string">"index:"</span> + index + <span class="string">",dataLen:"</span> + data.length + <span class="string">",len:"</span> + len + <span class="string">",rate:"</span> + rate + <span class="string">",timestamp:"</span> + timestamp + <span class="string">",width:"</span> + width + <span class="string">",height:"</span> + height);</div><div class="line">    mediaCodecDecoder.sendData(<span class="keyword">new</span> VideoData(subType, data));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>假设 onVideoDataCallback 是一个码流回调接口，那就可以直接调用解码器的 sendData() 进行解码操作了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendData</span><span class="params">(VideoData videoData)</span> </span>&#123;</div><div class="line">    decoderQueue.offer(videoData);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到主要是给解码器中的队列塞进待解码数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public MediaCodecDecoder() &#123;</div><div class="line">   mFuture = ThreadPool.submit(this);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面我们说到解码器里面除了解码队列还有一个解码线程，解码线程是在初始化解码器的时候就创建的，而且还是从线程池中获取的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">while</span> (!isFinish) &#123;</div><div class="line">                VideoData data = decoderQueue.take();<span class="comment">//方法阻塞，有数据时继续执行。</span></div><div class="line"><span class="comment">//               Log.d(TAG, "queue size:" + decoderQueue.size() + " ,Frame_Type:" + data.getSubType());</span></div><div class="line">                decodeData(data);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>通过线程的 run() 方法可以看到线程内部是一个 while 循环，循环内则是通过队列的 take() 方法获取到队列出口的第一个数据然后进行 decodeData() 解码处理。线程中的队列是 LinkedBlockingDeque，它是一个线程同步的阻塞队列，这样能避免在没有码流上来的情况下子线程一直运行造成的资源损耗。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">decodeData</span><span class="params">(VideoData videodata)</span> </span>&#123;</div><div class="line">  	<span class="keyword">if</span> (decoderQueue.size() &gt;= <span class="number">10</span> * mVDConfig.getFramerate()) &#123;</div><div class="line">	isIncrease = <span class="keyword">false</span>;</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isIncrease &amp;&amp; decoderQueue.size() &lt;= mVDConfig.getFramerate()) &#123;</div><div class="line">	isIncrease = <span class="keyword">true</span>;</div><div class="line">          isDecode = <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line">  	</div><div class="line">  	<span class="keyword">if</span> (!isIncrease &amp;&amp; videodata.getSubType() != <span class="number">1</span>) &#123;</div><div class="line">	<span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (!isDecode) &#123;</div><div class="line">          <span class="keyword">if</span> (videodata.getSubType() == <span class="number">1</span>) &#123;</div><div class="line">              isDecode = <span class="keyword">true</span>;</div><div class="line">          &#125; <span class="keyword">else</span> &#123;</div><div class="line">              <span class="keyword">return</span>;</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">  	</div><div class="line">  	<span class="keyword">byte</span>[] data = videodata.getData();</div><div class="line">  	</div><div class="line">      <span class="keyword">if</span> (!mIsStart) &#123;</div><div class="line">          Log.w(TAG, <span class="string">"decodeData fail decoder is not start"</span>);</div><div class="line">          <span class="keyword">return</span>;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (data == <span class="keyword">null</span>) &#123;</div><div class="line">          Log.w(TAG, <span class="string">"decodeData data is null"</span>);</div><div class="line">          <span class="keyword">return</span>;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">//重置开始时间</span></div><div class="line">      startTime = System.currentTimeMillis();</div><div class="line"></div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">          ByteBuffer[] buffers = mMediaCodec.getInputBuffers();</div><div class="line">          <span class="comment">//-1表示一直等待；0表示不等待；其他大于0的参数表示等待毫秒数</span></div><div class="line">          <span class="keyword">int</span> index = mMediaCodec.dequeueInputBuffer(-<span class="number">1</span>);</div><div class="line"></div><div class="line">          <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</div><div class="line">              ByteBuffer buffer = buffers[index];</div><div class="line">              buffer.clear();</div><div class="line">              buffer.put(data, <span class="number">0</span>, data.length);</div><div class="line">              mMediaCodec.queueInputBuffer(index, <span class="number">0</span>, data.length, mCount * <span class="number">1000000</span> /    mVDConfig.getFramerate(), <span class="number">0</span>);</div><div class="line">              mCount++;</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          MediaCodec.BufferInfo bufferInfo = <span class="keyword">new</span> MediaCodec.BufferInfo();</div><div class="line">          <span class="keyword">int</span> outputIndex = mMediaCodec.dequeueOutputBuffer(bufferInfo, <span class="number">11000</span>);</div><div class="line">          <span class="keyword">while</span> (outputIndex &gt;= <span class="number">0</span>) &#123;</div><div class="line">              mMediaCodec.releaseOutputBuffer(outputIndex, <span class="keyword">true</span>);</div><div class="line">              outputIndex = mMediaCodec.dequeueOutputBuffer(bufferInfo, <span class="number">11000</span>);</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">if</span> (decoderQueue.size() &lt; mVDConfig.getFramerate()) &#123;</div><div class="line">              <span class="comment">//线程休眠</span></div><div class="line">              sleepThread(mVDConfig.getFramerate(), startTime, System.currentTimeMillis());</div><div class="line">          &#125;</div><div class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">          Log.e(TAG, <span class="string">"decodeData Exception"</span>);</div><div class="line">          e.printStackTrace();</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>视频数据 dequeueOutputBuffer() 方法塞给 MediaCodec 进行硬解处理（要注意第三个参数是时间戳，既需要播放的时间，因此要线性增加，注意单位是微秒），然后再通过 dequeueOutputBuffer() 函数取出解码后的视频数据。</p>
<p>视频在播放的时候是以一帧一帧的形式播放的，类似于一张张图片播放。如果在单通道播放的情况下注释掉 sleepThread() 函数会发现视频播放很快，原因在于每一帧数据上来解码器都能很快进行操作并播放，比如这一帧的数据是在第5秒钟播放的，现在在第2秒钟就播了，而且前面的视频帧全部都提前播放了。所以对于每一帧视频做了相应的处理，使他们能以相对正常的进度播放。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sleepThread</span><span class="params">(<span class="keyword">int</span> rate, <span class="keyword">long</span> startTime, <span class="keyword">long</span> endTime)</span> </span>&#123;</div><div class="line">    <span class="comment">//计算需要休眠的时间</span></div><div class="line">    <span class="keyword">long</span> time = <span class="number">1000</span> / rate - (endTime - startTime);</div><div class="line">    <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread.sleep(time);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>具体处理的策略就是每一帧视频播放的间隔减去代码解码需要的时间就是线程需要睡眠的时间。但是在实际的使用过程中，我们发现如果同时打开多路视频的情况，这时候队列内的数据会不断增加，这会导致越播越慢的情况。比如一个视频要一分钟播放，但是却播了两分钟，原因是由于在多路解码的情况下如果超出硬件设备所能支持的最大硬解限制就会导致解码的时间比帧间隔的时间还长，造成延迟的现象。这时候为了保证实时性，当队列内的视频帧数据超过一秒钟（可根据实际需求更改）的大小时，我们不会对视频帧进行睡眠处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">  	<span class="keyword">if</span> (decoderQueue.size() &gt;= <span class="number">10</span> * mVDConfig.getFramerate()) &#123;</div><div class="line">	isIncrease = <span class="keyword">false</span>;</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isIncrease &amp;&amp; decoderQueue.size() &lt;= mVDConfig.getFramerate()) &#123;</div><div class="line">	isIncrease = <span class="keyword">true</span>;</div><div class="line">          isDecode = <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line">  	</div><div class="line">  	<span class="keyword">if</span> (!isIncrease &amp;&amp; videodata.getSubType() != <span class="number">1</span>) &#123;</div><div class="line">	<span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line">      <span class="comment">// 当队列大小小于一秒钟播放的帧数时，直到 I 帧出来后才开始所有类型帧的解码</span></div><div class="line">      <span class="keyword">if</span> (!isDecode) &#123;</div><div class="line">          <span class="keyword">if</span> (videodata.getSubType() == <span class="number">1</span>) &#123;</div><div class="line">              isDecode = <span class="keyword">true</span>;</div><div class="line">          &#125; <span class="keyword">else</span> &#123;</div><div class="line">              <span class="keyword">return</span>;</div><div class="line">          &#125;</div><div class="line">      &#125;</div></pre></td></tr></table></figure>
<p>在decodeData() 函数的前面部分存在了这样的一段代码，它的策略是为了保证存在播放多路视频的需求，但是又要尽可能的保证实时性。当多路视频的情况下，设备硬解码的时间大于帧间隔，这时候队列内的数据越来越多，当数据的大小达到可以播放 10 秒（可根据实际需求更改）视频的时候，这时候只对队列内的 I 帧（关键帧）进行解码播放，而 P帧 和 B 帧 统统扔掉，当队列大小小于一秒钟（可根据实际需求更改）播放的帧数时，直到 I 帧出来后又让解码器可以解析所有类型的视频帧，这样即可保证视频的实时性（当然也有其他的策略）。</p>
<h4 id="3-释放解码器"><a href="#3-释放解码器" class="headerlink" title="3.释放解码器"></a>3.释放解码器</h4><p>当视频解码完成后，要对解码器进行释放处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</div><div class="line">        setFinish(<span class="keyword">true</span>);</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (!mIsStart) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">try</span>&#123;</div><div class="line">            mMediaCodec.stop();</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            Log.e(TAG, <span class="string">"stop stop Exception"</span> + e.getMessage());</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">try</span>&#123;</div><div class="line">            mMediaCodec.release();</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            Log.e(TAG, <span class="string">"stop release Exception"</span> + e.getMessage());</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"><span class="comment">//        Log.e(TAG, "stop MediaCodec success");</span></div><div class="line">        startTime = <span class="number">0</span>;</div><div class="line">        mVDConfig = <span class="keyword">null</span>;</div><div class="line">        mMediaCodec = <span class="keyword">null</span>;</div><div class="line">        mIsStart = <span class="keyword">false</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>设置 setFinish(true) 释放掉线程的循环，再依次调用 mMediaCodec.stop() 和 mMediaCodec.release() 停止解码并释放。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上是本人基于自己对视频硬解的理解封装的解码器，其中所涉及的播放策略可根据自己的实际需求进更改并改进。</p>
<p><a href="https://github.com/airxiao/MediaDecoder" target="_blank" rel="external">Github地址：https://github.com/airxiao/MediaDecoder</a></p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 视频解码 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android 屏幕适配总结]]></title>
      <url>/2018/02/28/Android-%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>Android 的碎片化越来越严重，因此屏幕适配十分重要但又比较繁琐，现对 Android 的屏幕适配做下总结。</p>
<a id="more"></a>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Android 屏幕适配必须了解的几个概念：</p>
<ul>
<li><p>px</p>
<p>意为像素，是用来计算数码影像的最小单位。</p>
</li>
<li><p>in</p>
<p>表示英寸，指的是手机屏幕对角线长度（我们平时说手机 xx 寸就是指英寸）。</p>
</li>
<li><p>dpi</p>
<p>表示每英寸点数，即每英寸包含像素个数。比如320X480分辨率的手机，宽2英寸，高3英寸, 每英寸包含的像素点的数量为320/2=160dpi（横向）或480/3=160dpi（纵向），160就是这部手机的dpi，横向和纵向的这个值都是相同的。</p>
</li>
<li><p>density</p>
<p>屏幕密度，density和dpi的关系为 density = dpi/160</p>
</li>
<li><p>dp</p>
<p>也即dip，设备独立像素，device independent pixels的缩写，Android特有的单位。在屏幕密度dpi = 160屏幕上，1dp = 1px。</p>
</li>
</ul>
<h3 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h3><p>各类型设备屏幕对应的 dpi 等级、屏幕像素密度、屏幕密度如下表。</p>
<table>
<thead>
<tr>
<th style="text-align:center">设备 dpi 等级</th>
<th style="text-align:center">屏幕像素密度（dpi）</th>
<th style="text-align:center">屏幕密度（density）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ldpi</td>
<td style="text-align:center">120</td>
<td style="text-align:center">0.75</td>
</tr>
<tr>
<td style="text-align:center">mdpi</td>
<td style="text-align:center">160</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">dpi</td>
<td style="text-align:center">240</td>
<td style="text-align:center">1.5</td>
</tr>
<tr>
<td style="text-align:center">xhdpi</td>
<td style="text-align:center">320</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">xxhdpi</td>
<td style="text-align:center">480</td>
<td style="text-align:center">3</td>
</tr>
</tbody>
</table>
<p>我们知道一个 Android 项目的资源文件下有很多类型的 drawable 文件夹，分别对应不同的 dpi。</p>
<table>
<thead>
<tr>
<th style="text-align:center">drawable 文件等级</th>
<th style="text-align:center">dpi（drawable）</th>
<th style="text-align:center">density（drawable）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">drawable-ldpi</td>
<td style="text-align:center">120</td>
<td style="text-align:center">0.75</td>
</tr>
<tr>
<td style="text-align:center">drawable-mdpi</td>
<td style="text-align:center">160</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">drawable-hdpi</td>
<td style="text-align:center">240</td>
<td style="text-align:center">1.5</td>
</tr>
<tr>
<td style="text-align:center">drawable-xhdpi</td>
<td style="text-align:center">320</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">drawable-xxhdpi</td>
<td style="text-align:center">480</td>
<td style="text-align:center">3</td>
</tr>
</tbody>
</table>
<p><strong>当我们在宽高都设置为 wrap_content 的 ImageView 控件中插入一张图片，那么这张图片的尺寸换算成 dp 该如何计算呢？显示在设备上又应该是多少像素呢？</strong></p>
<ol>
<li>dp = 图片尺寸像素 / 图片所在drawable 文件等级的 density</li>
<li>设备上显示的像素 = dp * 设备屏幕密度（density）</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>在宽高都设置为 wrap_content 的 ImageView 控件中插入一张图片，如果图片依次放在 drawable 文件 dpi 越大的文件中，控件的 dp 就越小，ImageView 在设备上显示的尺寸也越小，图片在 ImageView 展示就会被压缩。</li>
<li>在宽高都设置为 wrap_content 的 ImageView 控件中插入一张来自 drawable-mdpi 文件等级的 120 * 120 图片，其宽高的 dp = 120 / 1 = 120，其展示效果和把图片放入一个宽高都设置为 120dp 的控件中的展示效果一样。但是如果把图片放到大于宽高都设置为 120dp 的控件中，那么图片就会被拉伸显得模糊；反之则会被压缩。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 适配 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[从源码角度分析 Handler、Looper、Message、MessageQuene]]></title>
      <url>/2018/02/26/%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90-Handler%E3%80%81Looper%E3%80%81Message%E3%80%81MessageQuene/</url>
      <content type="html"><![CDATA[<p>Android 的线程间通信主要是通过 Handler 来实现，那么具体是怎么实现运转的呢？下面就从源码的角度进行分析。</p>
<a id="more"></a>
<p>首先从英文字面上这几个单词可以理解为 Handler（执行者），Looper（循环者），Message（消息），MessageQuene（消息队列）。</p>
<h3 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h3><p>我们在子线程使用 Handler 的时候一定要调用 Looper 的以下两个函数（主线程默认已经调用了这两个函数）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">looper.prepare()</div><div class="line">looper.loop()</div></pre></td></tr></table></figure>
<h5 id="looper-prepare"><a href="#looper-prepare" class="headerlink" title="looper.prepare()"></a>looper.prepare()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</div><div class="line">    &#125;</div><div class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 prepare() 方法中，我们看到了一个全局变量 ThreadLocal。ThreadLocal 是一个线程内部的数据存储类，在 Handler 的运行机制中具有很重要的作用，它可以在指定的线程中存储数据，数据存储后，只有在指定线程中可以获取到存储的数据，对于其他线程来说无法获取到数据。对于 Handler 来说，它需要获取当前线程的 Looper，这个时候通过 ThreadLocal 就能轻松实现 Looper 在当前线程中的获取。</p>
<p>在 prepare() 函数中，当前线程下 ThreadLocal 如果取不到 Looper 对象，便会在 ThreadLocal 中创建一个当前线程下的 Looper。继续看 Looper 的构造函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</div><div class="line">    mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</div><div class="line">    mThread = Thread.currentThread();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 可以发现 Looper 内维护了一个消息队列和一个线程。</p>
<h5 id="looper-loop"><a href="#looper-loop" class="headerlink" title="looper.loop()"></a>looper.loop()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Looper me = myLooper();</div><div class="line">    <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">final</span> MessageQueue queue = me.mQueue;</div><div class="line"></div><div class="line">    <span class="comment">// Make sure the identity of this thread is that of the local process,</span></div><div class="line">    <span class="comment">// and keep track of what that identity token actually is.</span></div><div class="line">    Binder.clearCallingIdentity();</div><div class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        Message msg = queue.next(); <span class="comment">// might block</span></div><div class="line">        <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">// No message indicates that the message queue is quitting.</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></div><div class="line">        <span class="keyword">final</span> Printer logging = me.mLogging;</div><div class="line">        <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</div><div class="line">            logging.println(<span class="string">"&gt;&gt;&gt;&gt;&gt; Dispatching to "</span> + msg.target + <span class="string">" "</span> +</div><div class="line">                    msg.callback + <span class="string">": "</span> + msg.what);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">long</span> traceTag = me.mTraceTag;</div><div class="line">        <span class="keyword">if</span> (traceTag != <span class="number">0</span> &amp;&amp; Trace.isTagEnabled(traceTag)) &#123;</div><div class="line">            Trace.traceBegin(traceTag, msg.target.getTraceName(msg));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            msg.target.dispatchMessage(msg);</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</div><div class="line">                Trace.traceEnd(traceTag);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</div><div class="line">            logging.println(<span class="string">"&lt;&lt;&lt;&lt;&lt; Finished to "</span> + msg.target + <span class="string">" "</span> + msg.callback);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Make sure that during the course of dispatching the</span></div><div class="line">        <span class="comment">// identity of the thread wasn't corrupted.</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">long</span> newIdent = Binder.clearCallingIdentity();</div><div class="line">        <span class="keyword">if</span> (ident != newIdent) &#123;</div><div class="line">            Log.wtf(TAG, <span class="string">"Thread identity changed from 0x"</span></div><div class="line">                    + Long.toHexString(ident) + <span class="string">" to 0x"</span></div><div class="line">                    + Long.toHexString(newIdent) + <span class="string">" while dispatching to "</span></div><div class="line">                    + msg.target.getClass().getName() + <span class="string">" "</span></div><div class="line">                    + msg.callback + <span class="string">" what="</span> + msg.what);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        msg.recycleUnchecked();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 loop() 方法中可以看到又一个 for 循环，循环每次都从 MessageQuene 中取出 Message，当取出的 Message 为空的时候就直接 return 掉，否则执行 <strong>msg.target.dispatchMessage(msg)</strong>（分发该消息，msg.target 是什么待会再说）。</p>
<h3 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h3><p>Handler 在发送消息的时候有许多种方法，大多都是要通过 sendMessageAtTime() 发送。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</div><div class="line">    MessageQueue queue = mQueue;</div><div class="line">    <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</div><div class="line">        RuntimeException e = <span class="keyword">new</span> RuntimeException(</div><div class="line">                <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</div><div class="line">        Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>enqueueMessage() 方法代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</div><div class="line">    msg.target = <span class="keyword">this</span>;</div><div class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;</div><div class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到 Message 正是在这个方法内被 Handler 装进了 MessageQuene。更让人激动的是我们发现了 msg.target = this 这行代码，这也就意味着在 Looper 的 loop() 方法中，msg.target.dispatchMessage(msg) 表示执行消息分发的是 Handler。我们再去 Handler 中搜索 dispatchMessage() 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</div><div class="line">        handleCallback(msg);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        handleMessage(msg);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>发现了我们熟悉的 handleMessage(msg) 方法，原来回调都是在这里。</p>
<p>至此，整个流程大致如下：</p>
<p><strong>Handler 执行发送消息的相关方法后，Message 被装进 MessageQuene 中。线程中的 Looper 则是在 loop() 方法内不断尝试从 MessageQuene 内取出 Message，然后调用与该 Message 绑定的 Handler（msg.target）对象的 dispatchMessage() 方法。最后可以看到处理消息的 handleMessage() 方法就是在 dispatchMessage() 方法内被调用的。</strong></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>在线程间通信中，子线程通过调用主线程的 Handler 的发送消息函数把子线程的 Message 发送到 MessageQuene 中。由于主线程默认调用了 Looper.loop() 方法，他会不断地去查询主线程的 MessageQuene 中是否有 Message 对象，如果有的话就把对象取出给主线程的 Handler 进行处理，从而达到了线程间通信。</li>
</ol>
<ol>
<li>一个线程可以有多个 Handler，但是一个线程只能对应一个 Looper 和一个 MessageQuene。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 源码分析 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android 中常见的内存泄漏总结]]></title>
      <url>/2018/01/31/Android-%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>在 Android 开发中，稍有不慎就容易引起内存泄漏，我们经常听到内存泄漏，但是什么是内存泄漏呢？</p>
<a id="more"></a>
<blockquote>
<p>内存泄漏：无用对象持续占用内存使得内存资源得不到及时释放，导致内存资源被浪费。</p>
</blockquote>
<p>可以看到内存泄漏是由于没有及时释放内存资源造成的，因此在不经意间我们就有可能造成了内存泄露。本文我们就来汇总下平时的编码过程中容易发生内存泄漏的地方并举例加以说明以及给出解决措施。</p>
<h4 id="1-集合类造成的内存泄露"><a href="#1-集合类造成的内存泄露" class="headerlink" title="1. 集合类造成的内存泄露"></a>1. 集合类造成的内存泄露</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Vector v = <span class="keyword">new</span> Vector(<span class="number">10</span>);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;<span class="number">100</span>; i++) &#123;</div><div class="line">	Object o = <span class="keyword">new</span> Object();</div><div class="line">	v.add(o);</div><div class="line">	o = <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这一例子是典型的集合类造成的泄漏。</p>
<p>这个例子中循环申请了 Object 对象，虽然最后将每个对象进行了释放，但是 Vector 依然持有该对象的引用，这对于 GC 来说是不能进行回收的。</p>
<p>所以，避免该方式的内存泄漏最简单的方法是将 Vector 置为空（v = null）</p>
<h4 id="2-单例造成的内存泄漏"><a href="#2-单例造成的内存泄漏" class="headerlink" title="2. 单例造成的内存泄漏"></a>2. 单例造成的内存泄漏</h4><p>单例模式在我们编写代码的过程中经常会用到，但是使用不慎也是极其容易引起内存泄漏。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppManager</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> AppManager instance;</div><div class="line">	<span class="keyword">private</span> Context context;</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="title">AppManager</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.context = context;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AppManager <span class="title">getInstance</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</div><div class="line">			instance = <span class="keyword">new</span> AppManager(context);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> instance;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这个例子是一个普通的单例模式，我们在创建的时候传入了 Context，但是对于传入的 Context 是非常有讲究的，一不小心就很可能造成内存泄漏。</p>
<ol>
<li>传入 Application 的 Context。因为 Application 的生命周期就是整个应用的生命周期，所以这不会有问题。</li>
<li>传入 Activity 的 Context。单传入的 Activity 要退出的时候，由于单例对象是静态的，其生命周期就是整个应用的生命周期，导致 Activity 在退出的时候单例对象一直持有 Activity 的引用使得 Activity 不能被回收，因而便造成了内存泄漏。</li>
</ol>
<p>避免内存泄漏的方式可以参考下面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">在应用的 Applicaiton 中添加一个静态方法</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Context <span class="title">getContext</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> getApplicationContext();</div><div class="line">&#125;</div><div class="line">*****************************************************************</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppManager</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> AppManager instance;</div><div class="line">	<span class="keyword">private</span> Context context;</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="title">AppManager</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.context = App.getContext();<span class="comment">// 使用Application 的context</span></div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AppManager <span class="title">getInstance</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</div><div class="line">			instance = <span class="keyword">new</span> AppManager(context);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> instance;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样创建的单例对象可直接调用 Application 的 Context，避免了内存泄漏。</p>
<h4 id="3-非静态内部类创建静态实例造成的内存泄漏"><a href="#3-非静态内部类创建静态实例造成的内存泄漏" class="headerlink" title="3. 非静态内部类创建静态实例造成的内存泄漏"></a>3. 非静态内部类创建静态实例造成的内存泄漏</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> TestResource mResource = <span class="keyword">null</span>;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">		setContentView(R.layout.activity_main);</div><div class="line">		<span class="keyword">if</span>(mManager == <span class="keyword">null</span>)&#123;</div><div class="line">		mManager = <span class="keyword">new</span> TestResource();</div><div class="line">		&#125;</div><div class="line">		<span class="comment">//...</span></div><div class="line">	&#125;</div><div class="line">  </div><div class="line">	<span class="class"><span class="keyword">class</span> <span class="title">TestResource</span> </span>&#123;</div><div class="line">  		<span class="comment">//...</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有时候某个 Activity 会被频繁启动，为了避免资源重复创建，就可能出现上面这种写法。</p>
<p>我们知道<strong>非静态内部类会默认持有外部类的引用</strong>。因此，这个 TestResource 会默认持有 MainActivity 的引用，而该非静态内部类又创建了一个静态实例，所以该实例的生命周期和应用一样长。如果我们要销毁这个 MainActivity，这个静态实例会持有 MainActivity 的引用，导致 MainActivity 的资源无法回收，造成了内存泄漏。</p>
<p>正确的做法是将该内部类设为静态内部类，这样静态内部类就不持有外部类的引用了，避免了内存泄漏。</p>
<h4 id="4-匿名内部类造成的内存泄漏"><a href="#4-匿名内部类造成的内存泄漏" class="headerlink" title="4. 匿名内部类造成的内存泄漏"></a>4. 匿名内部类造成的内存泄漏</h4><p>这种情况下造成的内存泄漏和上一种分析的状况有些类似，先看下面这一例子。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;  </div><div class="line">   </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;  </div><div class="line">      	<span class="keyword">super</span>.onCreate(savedInstanceState);  </div><div class="line">      	exampleOne();  </div><div class="line">    &#125;  </div><div class="line">   </div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exampleOne</span><span class="params">()</span> </span>&#123;  </div><div class="line">		<span class="keyword">new</span> Thread() &#123;<span class="comment">//匿名内部类，非静态的匿名类会持有外部类的一个隐式引用  </span></div><div class="line">			<span class="meta">@Override</span>  </div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </div><div class="line">				...</div><div class="line">			&#125;  </div><div class="line">		&#125;.start();  </div><div class="line">	&#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>非静态匿名内部类会默认持有外部类的引用</strong>（这和上一个例子中提到的非静态内部类会默认持有外部类的引用是一样的），因此这个新创建的线程会持有 MainActivity 的引用。而如果要销毁这个 Activity 之前，线程还在运行的话就会造成该线程持有 MainActivity 的引用，造成 MainActivity 的资源无法回收导致内存泄漏。</p>
<p>针对上述情况有两种解决方法。</p>
<ol>
<li>把非静态的线程匿名类定义成静态的内部类，这样静态的内部类就不会持有外部类的隐式引用。</li>
<li>在销毁 MainActivity 的 onDestroy() 方法中结束运行的线程。</li>
</ol>
<h4 id="5-Handler-造成的内存泄漏"><a href="#5-Handler-造成的内存泄漏" class="headerlink" title="5. Handler 造成的内存泄漏"></a>5. Handler 造成的内存泄漏</h4><p>我们为了避免发生 ANR 而不在主线程进行耗时操作经常要用到 Handler，但是使用的时候极有可能造成内存泄漏。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Handler handler = <span class="keyword">new</span> Handler() &#123;</div><div class="line">    	<span class="meta">@Override</span></div><div class="line">    	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">      	<span class="comment">// ...</span></div><div class="line">    	&#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">    	<span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">    	handler.postDelayed(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">      		<span class="meta">@Override</span></div><div class="line">      		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</div><div class="line">    	&#125;, <span class="number">1000</span> * <span class="number">60</span>);</div><div class="line"></div><div class="line">    finish();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>例子中在 MainActivity 中声明了一个延迟一分钟的 Message。当我们 finish() 掉 MainActivity 的时候，如果 MeassageQuene 里面还有 Message，那个延迟执行的 Message 会继续存在主线程中，它会持有 handler 的引用，而因为 handler 是非静态内部类，它默认持有 MainActivity 的隐式引用，从而造成了内存泄漏。</p>
<p>解决方法应该是把 handler 声明为静态，这样就不持有 MainActivity 的引用了。同时通过弱引用的方式引入 Activity，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line">  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">    	<span class="keyword">private</span> <span class="keyword">final</span> WeakReference&lt;MainActivity&gt; mActivity;</div><div class="line"></div><div class="line">    	<span class="function"><span class="keyword">public</span> <span class="title">MyHandler</span><span class="params">(SampleActivity activity)</span> </span>&#123;</div><div class="line">      		mActivity = <span class="keyword">new</span> WeakReference&lt;MainActivity&gt;(activity);</div><div class="line">    	&#125;</div><div class="line"></div><div class="line">    	<span class="meta">@Override</span></div><div class="line">   	 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">      		MainActivity activity = mActivity.get();</div><div class="line">      		<span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</div><div class="line">        		<span class="comment">// ...</span></div><div class="line">      		&#125;</div><div class="line">    	&#125;</div><div class="line">  	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> MyHandler handler = <span class="keyword">new</span> MyHandler(<span class="keyword">this</span>);</div><div class="line">  </div><div class="line">  	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Runnable mRunnable = <span class="keyword">new</span> Runnable() &#123;</div><div class="line">      <span class="meta">@Override</span></div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</div><div class="line">   &#125;;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">    	<span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">    	handler.postDelayed(mRunnable, <span class="number">1000</span> * <span class="number">60</span>);</div><div class="line"></div><div class="line">    finish();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里提到了 WeakReference，再贴个图了解下其他几种引用类型。</p>
<p><img src="https://camo.githubusercontent.com/068950c506eddc68677d6a84b5d7ffe1c03c6cf9/68747470733a2f2f67772e616c6963646e2e636f6d2f7470732f5442315536544e4c565858585863685846585858585858585858582d3634342d3534362e6a7067" alt="Java引用类型"></p>
<h4 id="6-资源未关闭造成的内存泄漏"><a href="#6-资源未关闭造成的内存泄漏" class="headerlink" title="6. 资源未关闭造成的内存泄漏"></a>6. 资源未关闭造成的内存泄漏</h4><p>这种类型的内存泄漏时最直接的。比如对于使用了 BraodcastReceiver，ContentObserver，File，游标 Cursor，Stream，Bitmap，监听器等资源，应该在 Activity 销毁之前及时关闭或者注销，否则就会导致资源不会被回收造成内存泄漏。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本文罗列了 Android 常见的几种内存泄漏情况，如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1. 集合类造成的内存泄漏</div><div class="line">2. 单例造成的内存泄漏</div><div class="line">3. 非静态内部类创建静态实例造成的内存泄漏</div><div class="line">4. 匿名内部类造成的内存泄漏</div><div class="line">5. Handler 造成的内存泄漏</div><div class="line">6. 资源未关闭造成的内存泄漏</div></pre></td></tr></table></figure>
<p>内存泄漏的发生场景可以为如下一句话：<strong>长生命周期的对象持有短生命周期对象的引用且该引用不能被回收。 </strong> </p>
<p>因此在写代码的时候要保持对<strong>生命周期</strong>的敏感，尤其注意单例、静态对象、全局性集合等的生命周期。</p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 内存泄漏 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android 免 key 定位组件]]></title>
      <url>/2018/01/25/Android-%E5%85%8D-key-%E5%AE%9A%E4%BD%8D%E7%BB%84%E4%BB%B6/</url>
      <content type="html"><![CDATA[<p>之前在项目中遇到了定位需求，便在高德地图定位 SDK 的基础上封装了一层运用在项目中。后来部门提出了组件化的思想，因此又整理完善了，于是便有了这套<a href="https://github.com/airxiao/LBS" target="_blank" rel="external">定位组件</a>。</p>
<a id="more"></a>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol>
<li>免key使用。无需去官网申请key，直接依赖后即可使用</li>
<li>支持多种坐标系。只需设置好坐标系，就可以返回该坐标系下对应的经纬度</li>
<li>使用简便。支持一次性定位，持续定位，无需考虑之间切换逻辑</li>
<li>定位信息全面，包含了经纬度、街道信息、错误码、以及当前的GPS状态等详细信息</li>
</ol>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>这套组件是在高德地图基础上进行封装的，其最大的特点就是免申请 key 便可使用。之所以有这样的需求是因为我司的 Android 开发划分为好几个组，每个组支撑不同的行业线，因此组内资源要做到尽可能的共享，提高开发效率。因此，这也是该组件要想达到共享必须做到免 key 申请的原因（github地址：<a href="https://github.com/airxiao/LBS）。" target="_blank" rel="external">https://github.com/airxiao/LBS）。</a></p>
<p>关于如何破解高德地图定位 SDK 免 key 使用我不再叙述，网上也可以搜到相关资料也有，我也是参考了各路大神的方案才破解成功的，顺便也感谢下各位大神。</p>
<p><strong>参考资料：</strong></p>
<blockquote>
<p><a href="https://juejin.im/entry/5805dc4f570c35006b7af21d" target="_blank" rel="external">Android 破解高德地图 sdk 使用 map 免 key</a></p>
<p><a href="http://caiyao.name/2016/09/10/%E7%A0%B4%E8%A7%A3%E9%AB%98%E5%BE%B7SDK%E5%AE%9E%E7%8E%B0%E5%85%8Dkey/" target="_blank" rel="external">破解高德SDK实现免key</a></p>
</blockquote>
<h3 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h3><p>使用该组件只需要在应用中依赖 Demo 中的 location_lbs 模块即可 ，之所以说该组件使用简便是因为对于开发者来说，该组件总共只有 7 个接口对外提供。</p>
<ol>
<li>定位初始化：app内调用一次即可<br>@param  context<br>@param  coorType要设置坐标系，包括火星坐标系，大地坐标系，百度坐标系（详情见文档）<br>initLocation(Context context, CoorType coorType)</li>
<li>初始化<br>unInitLocation()</li>
<li>持续获取位置信息<br>@param scanTime  设置定位间隔时间<br>@param callback  定位信息回调<br>startContinuesLoc(int scanTime, LocationCallBack callBack)</li>
<li>停止持续获取位置信息<br>@param callback 定位信息回调（与startContinuesLoc中的回调相同实例）<br>stopContinuesLoc(LocationCallBack callBack)</li>
<li>只获取一次位置信息<br>@param callback定位信息回调<br>startLocationOnce(LocationCallBack callBack)</li>
<li>设置定位模式<br>@param mode 有省电模式、设备模式、高精度模式可供选择（详情见文档）<br>setLocationMode(LocMode mode)</li>
<li>判断GPS是否可用<br>isGpsEnabled()</li>
</ol>
<p>其中，在 LocationCallBack 的回调接口中不要忘记对错误码进行判断，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> 	<span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">locationResult</span><span class="params">(LocationInfo locationInfo)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (locationInfo.getErrorCode() == LocationInfo.LOCATION_SUCCESS) &#123;</div><div class="line">          </div><div class="line">       &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p><a href="https://github.com/airxiao/LBS" target="_blank" rel="external">更多使用详情大家可以参考demo 和文档说明，地址：https://github.com/airxiao/LBS</a>。</p>
<p>如果你认为该组件对你有所帮助的，麻烦您帮忙点个 star，小弟在此谢过了。</p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 定位组件 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[浅谈 == 和 equals() 的区别]]></title>
      <url>/2018/01/21/%E6%B5%85%E8%B0%88%20==%20%E5%92%8C%20equals()%20%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<p>在日常编写代码的过程中，== 和 equals() 经常用到。记得我刚开始写代码的时候也是弄不懂两者要在什么情况下使用，这篇文章就总结下二者的区别。</p>
<a id="more"></a>
<h3 id=""><a href="#" class="headerlink" title="=="></a>==</h3><p>在 Java 中总共有 8 种基本类型（int，float，byte，double，long，short，char，boolean）。而 == 常用于比较这些基本类型的值是否相等。其实，== 比较的是基本类型的引用是否指向堆内存的同一块地址。</p>
<h3 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h3><p>equals() 是对象间的比较，它比较的是堆内存中的内容是否相同。在一些子类中，如 String、Integer 等，该方法将被重写。</p>
<h3 id="String-中-和equals-的比较"><a href="#String-中-和equals-的比较" class="headerlink" title="String 中 == 和equals() 的比较"></a>String 中 == 和equals() 的比较</h3><p>先看一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">String str1 = <span class="string">"airxiao"</span>;</div><div class="line">   String str2 = <span class="string">"airxiao"</span>;</div><div class="line">   </div><div class="line">   System.out.println(str1 == str2);</div><div class="line">   System.out.println(str1.equals(str2));</div><div class="line">   </div><div class="line">   String str2 = <span class="keyword">new</span> String(<span class="string">"airxiao"</span>);</div><div class="line">   System.out.println(str1 == str2);</div><div class="line">   System.out.println(str1.equals(str2));</div></pre></td></tr></table></figure>
<p>其输入的结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//以上代码输出结果</span></div><div class="line"><span class="keyword">true</span></div><div class="line"><span class="keyword">true</span></div><div class="line"><span class="keyword">false</span></div><div class="line"><span class="keyword">true</span></div></pre></td></tr></table></figure>
<p>可能有人对第一个输出的结果为 true 会有点疑惑，这里要先了解下 String  的一些特性。Java 的虚拟机会在内存中单独开辟一块区域用于存储字符串对象，我们称这块区域为字符串缓冲池。我们知道创建一个字符串对象有如下两种方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String a = <span class="string">"airxiao"</span>;  <span class="comment">// 方法1</span></div><div class="line">String a = <span class="keyword">new</span> String(<span class="string">"airxiao"</span>);  <span class="comment">// 方法2</span></div></pre></td></tr></table></figure>
<p>对于方法 1 来说，它会先去字符串缓冲池中查找是否已经有相同的对象，如果存在的话，那么会直接把这个对象的栈内存地址直接返回给 a，如果不存在的话对象会进入字符串缓冲池再把这个对象的栈内存地址赋予给 a。</p>
<p>对于方法 2 来说，它会直接告诉虚拟机在堆内存中生成一个新的 String 对象，但是并不会进入字符串缓冲池。</p>
<p>现在，也就不难理解第一个输出结果为何为 true 了。由于在创建 str1 的时候已经在字符创缓冲池内存储了 airxiao 对象，因此在创建 str2 的时候由于字符创缓冲池内查找到了 airxiao 对象，就直接把 str1 的栈内存地址给了 str2。因此 str1 和 str2 就拥有了相同的栈内存地址。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实，equals() 是属于 Object 类中的一个方法，在 Objects 类中，equals() 方法的实现是和 == 一样的。而 String 是属于封装类型，它在内部对 equals() 方法进行了重写，equals() 的结果主要取决于重写实现。如果我们自定义了一个对象，若要比较对象是否相同，也需要对 equals() 方法进行重写。</p>
<p>最后，对于 == 和equals() 的区别，简单概括为 == 比较的是基本类型的引用是否指向堆内存的同一块地址，equals() 比较的是堆内存中的内容是否相同。</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java 总结 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[如何获取Android系统挂载U盘的路径]]></title>
      <url>/2017/10/21/%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96Android%E7%B3%BB%E7%BB%9F%E6%8C%82%E8%BD%BDU%E7%9B%98%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
      <content type="html"><![CDATA[<p>最近项目开发中碰到这样一个需求：用户在定制的 Android 设备上插入 U 盘，然后在应用内导入 U 盘里的文件内容。</p>
<a id="more"></a>
<p>问题在于如何获取 U 盘的路径，网上搜索后大多数都是采用广播监听的方式来获取 U 盘的路径。但是如果 U 盘在设备开机之前就插着，这样登录应用后就获取不到 U 盘的路径了，于是乎此种方法作罢。</p>
<p>这时候伟大同事告诉了另外一种方法，就是从文件中读取路径。</p>
<p>U 盘在插入系统后，如果系统检测到 U盘，便会在系统的 <strong>proc</strong> 目录的 <strong>mounts</strong> 文件内产生一条记录。</p>
<p><img src="http://ovjvgviry.bkt.clouddn.com/17-10-21/62630543.jpg" alt=""></p>
<p>可以看到该文件记录了 U 盘每一次插入的相关信息（看不清楚？好吧，我摘取其中的一条用日志打印出来如下）。</p>
<p><img src="http://ovjvgviry.bkt.clouddn.com/17-10-21/17814426.jpg" alt=""></p>
<p>很长的一条信息，可能你看不懂（其实我也看不懂），没关系，找到对自己有用的信息即可。是不是发现了 <strong>/mnt/sdaq/sdaq1</strong> 这样一条信息，没错，他就是我们需要的 U 盘挂载的路径。我们只需要把 <strong>/proc/mounts</strong> 文件内的带 <strong>vfat</strong> 的最后一行找到，截取其中的 U 盘路径即可。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">searchPath</span><span class="params">()</span> </span>&#123;</div><div class="line">       String filePath = <span class="string">"/proc/mounts"</span>;</div><div class="line">       File file = <span class="keyword">new</span> File(filePath);</div><div class="line">       List&lt;String&gt; lineList = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">       InputStream inputStream =<span class="keyword">null</span>;</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           inputStream = <span class="keyword">new</span> FileInputStream(file);</div><div class="line">           <span class="keyword">if</span> (inputStream != <span class="keyword">null</span>) &#123;</div><div class="line">               InputStreamReader inputStreamReader = <span class="keyword">new</span> InputStreamReader(inputStream, <span class="string">"GBK"</span>);</div><div class="line">               BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(inputStreamReader);</div><div class="line">               String line = <span class="string">""</span>;</div><div class="line">               <span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="keyword">null</span>) &#123;</div><div class="line">                   <span class="keyword">if</span> (line.contains(<span class="string">"vfat"</span>)) &#123;</div><div class="line">                       lineList.add(line);</div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</div><div class="line">           e.printStackTrace();</div><div class="line">       &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">           e.printStackTrace();</div><div class="line">       &#125; <span class="keyword">finally</span> &#123;</div><div class="line">           <span class="keyword">if</span> (inputStream != <span class="keyword">null</span>) &#123;</div><div class="line">               <span class="keyword">try</span> &#123;</div><div class="line">                   inputStream.close();</div><div class="line">               &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                   e.printStackTrace();</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       String editPath = lineList.get(lineList.size() - <span class="number">1</span>);</div><div class="line">       <span class="keyword">int</span> start = editPath.indexOf(<span class="string">"/mnt"</span>);</div><div class="line">       <span class="keyword">int</span> end = editPath.indexOf(<span class="string">" vfat"</span>);</div><div class="line">       String path = editPath.substring(start, end);</div><div class="line">       Log.d(<span class="string">"SelectBusLineDialog"</span>, <span class="string">"path: "</span> + path);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>最后，可能有小伙伴会问「既然是定制的 Android 设备，第一次插入的时候不是知道了 U 盘的路径了吗，只要以后写死这个路径不就好了吗」。好吧，其实当时我也是这么想的，但是实际上每次插拔 U 盘，路径是不断变化的，而且仔细看上面那张大图可以发现每条记录的 U 盘挂载路径都是不同的，这也是不能写死路径的原因。（PS：十分感谢同事「开志哥」在项目中给予的帮助）</p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> U盘挂载 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android 手机存储那些事儿]]></title>
      <url>/2017/08/31/Android-%E6%89%8B%E6%9C%BA%E5%AD%98%E5%82%A8%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/</url>
      <content type="html"><![CDATA[<p>最近项目开发新增清除缓存需求，于是查阅相关资料并结合功能的实现过程，对手机存储的相关知识做下总结。</p>
<a id="more"></a>
<p>首先看下这张图：</p>
<p><img src="http://ovjvgviry.bkt.clouddn.com/17-8-31/87807963.jpg" alt=""></p>
<p>可以看到，我们把手机存储分为了内部存储和外部存储。</p>
<h3 id="1-内部存储"><a href="#1-内部存储" class="headerlink" title="1. 内部存储"></a>1. 内部存储</h3><p>内部存储指的是存储在手机 /data/data/&lt;应用包名&gt; 目录下的数据，附上一张高清无码大图。</p>
<p><img src="http://ovjvgviry.bkt.clouddn.com/17-8-31/48236743.jpg" alt=""></p>
<p>从图中可以看到（注意：手机没 ROOT 是无法打开该文件夹的），内部存储有以下几种我们熟悉的数据：</p>
<p>files——文件存储（注：其对应路径 /data/data/&lt;应用包名&gt;/files 可通过 context.getFilesDir() 获取）</p>
<p>shared_prefs——sharedPreference 存储</p>
<p>cache——图片缓存（注：其对应路径 /data/data/&lt;应用包名&gt;/cache 可通过 context.getCacheDir() 获取，由于我的项目中用到了 Glide，所以发现 Glide 的图片存在了该目录下的 image_manager_disk_chache 文件夹内）</p>
<p>databases——数据库存储</p>
<h3 id="2-外部存储"><a href="#2-外部存储" class="headerlink" title="2. 外部存储"></a>2. 外部存储</h3><p>外部存储分为内置 SD 卡存储和拓展卡存储（外置 SD 卡）。</p>
<ul>
<li>内置 SD 卡：现在出产的手机基本都自带的，也就是我们常说的存储空间，有 16G，32G，64G，128G（以前的部分老旧低端机没有内置 SD 卡）</li>
<li>外置 SD 卡：可以插入手机的存储卡，扩大手机存储内存</li>
</ul>
<p>特别注意下，一般我们在新建文件夹的时候需要判断一下手机是否有 SD 卡，代码如下（项目中碰到的坑）:</p>
<p><code>Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)</code></p>
<p>对于 SD 卡的路径 /storage/sdcard，我们可以通过 Enviroment 中的方法获取到。</p>
<p><code>Environment.getExternalStorageDirectory()</code></p>
<p>SD 卡的文件路径也可以分为公有路径和私有路径。</p>
<h4 id="2-1-公有路径"><a href="#2-1-公有路径" class="headerlink" title="2.1 公有路径"></a>2.1 公有路径</h4><p>公有路径的获取方式如下：</p>
<p><code>Environment.getExternalStoragePublicDirectory(String type)</code></p>
<p>其参数共有 10 种类型，对应的参数和路径如下表：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>路径</th>
</tr>
</thead>
<tbody>
<tr>
<td>Environment.DIRECTORY_MUSIC</td>
<td>/storage/sdcard0/Music</td>
</tr>
<tr>
<td>DIRECTORY_PODCASTS</td>
<td>/storage/sdcard0/Podcasts</td>
</tr>
<tr>
<td>DIRECTORY_RINGTONES</td>
<td>/storage/sdcard0/Ringtones</td>
</tr>
<tr>
<td>DIRECTORY_ALARMS</td>
<td>/storage/sdcard0/Alarms</td>
</tr>
<tr>
<td>DIRECTORY_NOTIFICATIONS</td>
<td>/storage/sdcard0/Notifications</td>
</tr>
<tr>
<td>DIRECTORY_PICTURES</td>
<td>/storage/sdcard0/Pictures</td>
</tr>
<tr>
<td>DIRECTORY_MOVIES</td>
<td>/storage/sdcard0/Movies</td>
</tr>
<tr>
<td>DIRECTORY_DOWNLOADS</td>
<td>/storage/sdcard0/Download</td>
</tr>
<tr>
<td>DIRECTORY_DCIM</td>
<td>/storage/sdcard0/DCIM</td>
</tr>
<tr>
<td>DIRECTORY_DOCUMENTS</td>
<td>/storage/sdcard0/Documents</td>
</tr>
</tbody>
</table>
<h4 id="2-2-私有目录"><a href="#2-2-私有目录" class="headerlink" title="2.2 私有目录"></a>2.2 私有目录</h4><p>在 SD 卡目录下的 Android 文件夹就是对应的私有目录。打开 Android 目录，可以看到里面还有 data 文件夹，再打开这个文件夹，就是许多应用包名组成的文件夹。可以发现这些包名文件夹里面基本都包含有 files 和 cache 这两个文件夹。这两个文件夹的路径可以通过如下方法获取：</p>
<p>files——sdcard/Android/data/应用包名/files（注：可通过 context.getExternalFilesDir() 获取）</p>
<p>cache——sdcard/Android/data/应用包名/cache（注：可通过 context.getExternalCacheDir() 获取）</p>
<p>当调用 getExternalFilesDir() 和 getExternalCacheDir() 即可创建 files 和 cache 文件夹。看到这，你或许会问：</p>
<blockquote>
<p>这两个文件夹不是和我们上面看到的内部存储一样吗，为什么要存在这里面呢。</p>
</blockquote>
<p>原因在于内部存储空间有限，我们一般都是操作外部存储空间，虽然我们可以获得内部存储的路径，但是我们基本不会去操作内部空间，何况在没有 ROOT 情况下，也没法进行操作。而且 Google 官方也建议我们在外部存储的私有目录下进行数据存储操作。</p>
<p>这是或许你又会问：</p>
<blockquote>
<p>很多 APP 都是在 SD 卡目录下创建文件进行数据存储操作的。</p>
</blockquote>
<p>的确，很多 APP 是这么干的，但是当用户卸载 APP 的时候，<strong>内部存储</strong>中的包名文件夹及相关数据会被删除，<strong>外部存储</strong>的私有目录下相关数据也会跟随包名文件夹一起被删除，但是自己创建的文件夹是不会被删除的。在 sdcard 目录下创建文件不仅不利于系统维护，也会造成用户的反感（反正我是会经常去删除 SD 卡目录下的空文件夹）。</p>
<p>这时候我们再回到清除缓存这个功能上。对于需要被清除的数据，应该是内部存储中<strong>相应的 files</strong> 和 cache 文件夹内的数据和外部存储私有目录下<strong>相应的 files</strong> 和 cache 文件夹内的数据（可根据需求清除 files 文件夹内的相应数据）。</p>
<p>最后附上一个清除缓存数据的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CleanCacheManager</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * <span class="doctag">@param</span> context</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     * <span class="doctag">@throws</span> Exception</div><div class="line">     *             获取当前缓存</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getTotalCacheSize</span><span class="params">(Context context)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">long</span> cacheSize = getFolderSize(context.getCacheDir());</div><div class="line">        <span class="keyword">if</span> (Environment.getExternalStorageState().equals(</div><div class="line">                Environment.MEDIA_MOUNTED)) &#123;</div><div class="line">            cacheSize += getFolderSize(context.getExternalCacheDir());</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> getFormatSize(cacheSize);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * <span class="doctag">@param</span> context</div><div class="line">     *            删除缓存</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clearAllCache</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">        deleteDir(context.getCacheDir());</div><div class="line">        <span class="keyword">if</span> (Environment.getExternalStorageState().equals(</div><div class="line">                Environment.MEDIA_MOUNTED)) &#123;</div><div class="line">            deleteDir(context.getExternalCacheDir());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">deleteDir</span><span class="params">(File dir)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (dir != <span class="keyword">null</span> &amp;&amp; dir.isDirectory()) &#123;</div><div class="line">            String[] children = dir.list();</div><div class="line">            <span class="keyword">int</span> size = <span class="number">0</span>;</div><div class="line">            <span class="keyword">if</span> (children != <span class="keyword">null</span>) &#123;</div><div class="line">                size = children.length;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">                    <span class="keyword">boolean</span> success = deleteDir(<span class="keyword">new</span> File(dir, children[i]));</div><div class="line">                    <span class="keyword">if</span> (!success) &#123;</div><div class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (dir == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">            <span class="keyword">return</span> dir.delete();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 获取文件</span></div><div class="line">    <span class="comment">// Context.getExternalFilesDir() --&gt; SDCard/Android/data/你的应用的包名/files/</span></div><div class="line">    <span class="comment">// 目录，一般放一些长时间保存的数据</span></div><div class="line">    <span class="comment">// Context.getExternalCacheDir() --&gt;</span></div><div class="line">    <span class="comment">// SDCard/Android/data/你的应用包名/cache/目录，一般存放临时缓存数据</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getFolderSize</span><span class="params">(File file)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">long</span> size = <span class="number">0</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            File[] fileList = file.listFiles();</div><div class="line">            <span class="keyword">int</span> size2 = <span class="number">0</span>;</div><div class="line">            <span class="keyword">if</span> (fileList != <span class="keyword">null</span>) &#123;</div><div class="line">                size2 = fileList.length;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size2; i++) &#123;</div><div class="line">                    <span class="comment">// 如果下面还有文件</span></div><div class="line">                    <span class="keyword">if</span> (fileList[i].isDirectory()) &#123;</div><div class="line">                        size = size + getFolderSize(fileList[i]);</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        size = size + fileList[i].length();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> size;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 格式化单位</div><div class="line">     * 计算缓存的大小</div><div class="line">     * <span class="doctag">@param</span> size</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getFormatSize</span><span class="params">(<span class="keyword">double</span> size)</span> </span>&#123;</div><div class="line">        <span class="keyword">double</span> kiloByte = size / <span class="number">1024</span>;</div><div class="line">        <span class="keyword">if</span> (kiloByte &lt; <span class="number">1</span>) &#123;</div><div class="line">            <span class="comment">// return size + "Byte";</span></div><div class="line">            <span class="keyword">return</span> <span class="string">"0KB"</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">double</span> megaByte = kiloByte / <span class="number">1024</span>;</div><div class="line">        <span class="keyword">if</span> (megaByte &lt; <span class="number">1</span>) &#123;</div><div class="line">            BigDecimal result1 = <span class="keyword">new</span> BigDecimal(Double.toString(kiloByte));</div><div class="line">            <span class="keyword">return</span> result1.setScale(<span class="number">2</span>, BigDecimal.ROUND_HALF_UP)</div><div class="line">                    .toPlainString() + <span class="string">"KB"</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">double</span> gigaByte = megaByte / <span class="number">1024</span>;</div><div class="line">        <span class="keyword">if</span> (gigaByte &lt; <span class="number">1</span>) &#123;</div><div class="line">            BigDecimal result2 = <span class="keyword">new</span> BigDecimal(Double.toString(megaByte));</div><div class="line">            <span class="keyword">return</span> result2.setScale(<span class="number">2</span>, BigDecimal.ROUND_HALF_UP)</div><div class="line">                    .toPlainString() + <span class="string">"MB"</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">double</span> teraBytes = gigaByte / <span class="number">1024</span>;</div><div class="line">        <span class="keyword">if</span> (teraBytes &lt; <span class="number">1</span>) &#123;</div><div class="line">            BigDecimal result3 = <span class="keyword">new</span> BigDecimal(Double.toString(gigaByte));</div><div class="line">            <span class="keyword">return</span> result3.setScale(<span class="number">2</span>, BigDecimal.ROUND_HALF_UP)</div><div class="line">                    .toPlainString() + <span class="string">"GB"</span>;</div><div class="line">        &#125;</div><div class="line">        BigDecimal result4 = <span class="keyword">new</span> BigDecimal(teraBytes);</div><div class="line">        <span class="keyword">return</span> result4.setScale(<span class="number">2</span>, BigDecimal.ROUND_HALF_UP).toPlainString()</div><div class="line">                + <span class="string">"TB"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 存储 </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[致不安的自己]]></title>
      <url>/2017/07/08/%E8%87%B4%E4%B8%8D%E5%AE%89%E7%9A%84%E8%87%AA%E5%B7%B1/</url>
      <content type="html"><![CDATA[<p>昨天傍晚，<strong>stormzhang</strong> 推送了这篇文章《<a href="http://mp.weixin.qq.com/s/aP4KWyrKZAY8mbo9ul5Amg" target="_blank" rel="external">推荐一些不错的公众号</a>》。我反反复复看了好几遍，倒不是说文章写得多精彩，也不是推荐了对我来说相见恨晚的公众号，而是对比这些被推荐的公众号的作者，我产生了十足的羞愧感与不安。</p>
<a id="more"></a>
<p>自 2015 年偶然间关注了 <strong>stormzhang</strong>（改名前叫 <strong>AndroidDeveloper</strong>）这个公号，一直被张哥的人格魅力所折服，在张哥开通小密圈的时候也第一时间加入。张哥在圈子内多次提到「写作是一个短期内看不到任何好处，但是却是长期受益的事」，因此极力推荐大家去写作，养成写作的习惯。</p>
<p>在张哥的建议下我搭建了博客，准备开始自己的写作之路。然后从搭建博客至今，只是象征性得写了两篇技术文章，而且绝大部分内容和网上的同类型文章有高度的同质性。对比其他的小伙伴，大家纷纷建博客开公号，坚持写作，持续输出自己的内容，不免感到十分惭愧。</p>
<p>对于生活上总结出的观点或想法，我会记录下来心想下次写作或许用得上。然而随着笔记中的记录越来越多，我却感到愈发的不安。每次打算写作的时候心想还是晚上再写吧，等到了晚上又想着明天写吧，然后就不了了之。从这件事上看，我是一个执行力极弱的人。反思自己还想着要干这干那，成就自己的事业，简直是个笑话。经常对自己说「不要成为自己讨厌的那种人」，然而却在不经意间就成为了那种人。</p>
<p>最近在看阮一峰老师写的《<a href="https://ruanyf.github.io/survivor/index.html" target="_blank" rel="external">未来世界的幸存者</a>》这本书，联想到前段时间华为开始清理 34 岁以上员工的传言，愈发感到不安。身处这个剧烈变化的年代，人工智能、VR/AR 等新技术层出不穷。作为一个互联网开发人员，倘若不好好规划下自己的当下和未来，等过了人的生理和智能的巅峰后，那么被新人替代也不可避免了。</p>
<p><strong>投资自己是最好的投资</strong>。从这篇文章开始，养成定期写作的习惯，不要让自己成为自己讨厌的那种人。</p>
]]></content>
      
        <categories>
            
            <category> 生活 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 写作 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[手机抓包教程]]></title>
      <url>/2017/06/25/%E6%89%8B%E6%9C%BA%E6%8A%93%E5%8C%85%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>Android 开发中经常需要通过抓包来解决一些问题，今天就来讲下 Android 手机的抓包过程。</p>
<a id="more"></a>
<h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>手机抓包肯定需要手机啦，不过必须是 Root 过的手机，否则无法抓包，手机 Root 过程不再赘述，随便下载一个「ROOT 大师」之类的软件便可 Root 成功。除此之外必须要下载 <a href="https://pan.baidu.com/s/1o8LTZOu" target="_blank" rel="external">tcpdump</a>。工具都准备好了，接下来就可以开始 tcpdump 安装过程了。</p>
<h3 id="tcpdump-安装过程"><a href="#tcpdump-安装过程" class="headerlink" title="tcpdump 安装过程"></a>tcpdump 安装过程</h3><h4 id="1、安装-tcpdump"><a href="#1、安装-tcpdump" class="headerlink" title="1、安装 tcpdump"></a>1、安装 tcpdump</h4><p>通过 adb 命令把下载来的 tcpdump 导入手机。具体的 adb 命令如下：</p>
<ul>
<li>adb shell</li>
<li>su</li>
<li>chmod 777 /data/local – 给 /data/local 路径赋予访问权限</li>
</ul>
<p>接下来重新打开终端，把 tcpdump 复制进  /data/local 目录下，命令如下：</p>
<ul>
<li>adb push <strong>/Users/xiaoyunlou/抓包教程/tcpdump</strong> /data/local —注意粗体部分为 tcpdump 在电脑中的路径，只要把 tcpdump 拖进终端即可显示</li>
</ul>
<h4 id="2、给-tcpdump-赋予权限"><a href="#2、给-tcpdump-赋予权限" class="headerlink" title="2、给 tcpdump 赋予权限"></a>2、给 tcpdump 赋予权限</h4><p>重新打开终端，依次输入如下命令：</p>
<ul>
<li>adb shell</li>
<li>su</li>
<li>chmod 777 /data/local/tcpdump – 此步骤便是给 tcpdump 赋予权限</li>
</ul>
<p>至此，抓包前的准备都已完成，只要手机成功安装了 tcpdump 就可以开始抓包的操作了。</p>
<h3 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h3><p>重新打开终端，输入如下命令：</p>
<ul>
<li>adb shell</li>
<li>su</li>
<li>/data/local/tcpdump -p -s 0 -w /sdcard/6.pcap – 6.pcap就是抓到的包 </li>
</ul>
<p>这时候，如果终端显示</p>
<p><img src="https://ooo.0o0.ooo/2017/06/25/594fd9f07e3f4.png" alt="屏幕快照 2017-06-25 22.57.51"></p>
<p>则表示正在抓包，当做完网络相关操作便可在终端执行 ctrl + c 结束抓包。这时候你会在手机的根目录下看到一个 6.pcap 的文件，这便是我们抓到的包，最后执行下列命令即可把抓到的包复制到电脑上。</p>
<ul>
<li>adb pull /sdcard/6.pcap</li>
</ul>
<p>这时候我们就可以在电脑上通过 wireshark 之类的抓包分析工具对抓到的包进行分析了。</p>
]]></content>
      
        <categories>
            
            <category> 教程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 抓包 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[最新 MAC 上基于 Github + Hexo 博客搭建教程]]></title>
      <url>/2017/05/20/%E6%9C%80%E6%96%B0%20MAC%20%E4%B8%8A%E5%9F%BA%E4%BA%8E%20Github%20+%20Hexo%20%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>折腾了大半天的时间终于搭建好了自己的博客。在网上随便一搜就有一大堆搭建博客的教程，那为什么还要再写一遍呢。原因如下：</p>
<a id="more"></a>
<ul>
<li>网上绝大多数教程是基于 Windows 系统搭建的博客，在苹果系统上搭建博客的教程不多。</li>
<li>记录搭建博客过程中踩过的坑，帮助更多的小伙伴。 </li>
</ul>
<p>言归正传，接下来进入博客的搭建过程。</p>
<h3 id="1-Node-js-下载和安装"><a href="#1-Node-js-下载和安装" class="headerlink" title="1. Node.js 下载和安装"></a>1. Node.js 下载和安装</h3><p>下载地址：<a href="https://nodejs.org/en/download/" target="_blank" rel="external">Node.js 下载地址</a></p>
<h3 id="2-Git-的下载和安装"><a href="#2-Git-的下载和安装" class="headerlink" title="2. Git 的下载和安装"></a>2. Git 的下载和安装</h3><p>下载地址：<a href="https://git-scm.com/download/" target="_blank" rel="external">Git 下载地址</a></p>
<h3 id="3-Hexo-安装（重点）"><a href="#3-Hexo-安装（重点）" class="headerlink" title="3. Hexo 安装（重点）"></a>3. Hexo 安装（重点）</h3><ul>
<li><p>打开苹果电脑终端</p>
</li>
<li><p>输入安装命令 </p>
<p><code>$ sudo npm install -g hexo-cli</code></p>
</li>
<li><p>输入检验是否安装成功命令</p>
<p><code>$ hexo -v</code></p>
<p>若安装成功，会出现如下信息：</p>
<p><img src="http://i4.buimg.com/588926/a4a7f68b964afd96.jpg" alt=""></p>
</li>
<li><p>在 Mac 的 User 目录下新建文件夹，取名 Hexo</p>
</li>
<li><p>输入下面的命令，进入到 Hexo 目录下</p>
<p><code>$ cd Hexo/</code></p>
</li>
<li><p>输入下面命令，随后会在 Hexo 文件夹下简历网站所需要的所有文件</p>
<p><code>$ hexo init</code></p>
</li>
<li><p>现在，一个本地博客已经搭建成功，可以分别输入以下命令进行验证：</p>
<p><code>$ hexo g</code> –生成</p>
<p><code>$ hexo s</code> –启动服务本地预览</p>
<p>服务开启成功后到浏览器中输入 localhost:4000，这时候一个博客便映入眼帘。通过在终端输入Ctrl + C 可以停止本地预览</p>
</li>
</ul>
<h3 id="4-Github-Pages-设置"><a href="#4-Github-Pages-设置" class="headerlink" title="4. Github Pages 设置"></a>4. Github Pages 设置</h3><p>该部分可参考博客 <a href="https://adsuper.github.io/2017/03/19/%E5%9F%BA%E4%BA%8EHexo-Github-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AC%94%E8%AE%B0-1/" target="_blank" rel="external">珞璃之神-基于Hexo-Github—搭建个人博客笔记</a> 的第三部分「github Pages设置」</p>
<h3 id="5-更换博客主题"><a href="#5-更换博客主题" class="headerlink" title="5.  更换博客主题"></a>5.  更换博客主题</h3><p>在第 2 部分预览的时候，默认加载的主题是「landscape」。不过个人感觉「next」主题似乎更好看。</p>
<p><img src="http://i2.muimg.com/588926/9af6bd168a6db7c0.jpg" alt=""></p>
<p>自个体会下。</p>
<p>具体更换主题步骤如下：</p>
<ul>
<li><p>复制主题，在终端输入以下命令</p>
<p><code>$ git clone https://github.com/iissnan/hexo-theme-next themes/next</code></p>
</li>
<li><p>配置 Hexo 目录下的 config.yml 配置文件中的 theme 属性，将其设置为 next</p>
</li>
<li><p>启用 next 主题</p>
<p><code>$ cd themes/next</code> –在终端上从 Hexo 根目录进入你复制的主题目录</p>
<p><code>$ git pull</code></p>
<p><code>$ hexo clean</code> –清除默认的缓存主题</p>
<p><code>$ hexo g</code> –生成</p>
<p><code>$ hexo s</code> –启动本地预览</p>
</li>
<li><p>到浏览器中输入 localhost:4000 查看 next 主题是否更换成功</p>
</li>
</ul>
<p>至此，基于Github + Hexo 的博客也已经搭建成功！</p>
<h3 id="6-一键发布博客"><a href="#6-一键发布博客" class="headerlink" title="6. 一键发布博客"></a>6. 一键发布博客</h3><p>接下来，教大家一键部署博客到 Github 的方法。</p>
<p>此部分完全参考博客 <a href="https://smartbeng.github.io/2017/03/26/blogFinish/" target="_blank" rel="external">smartbeng-最适合新手的 GitHub + Hexo 「大话」博客搭建教程</a> ，内容如下：</p>
<ol>
<li><p>进入 Hexo 的根目录 接着操作以下命令</p>
<p><code>$ cd Hexo</code></p>
<p>注意 1：现在我们需要clone我们自己的GitHub仓库了</p>
<p>注意 3：切记下面是<strong>你自己的仓库名</strong> , 把名字都改过来 , 下面我用的是我的仓库名字</p>
<p><code>$ git clone https://github.com/storm/</code></p>
<p><code>strom.github.io.git .deploy/storm.github.io</code></p>
<p>翻译下这条命令的意思</p>
<p>将我们之前创建的GitHub 仓库克隆到本地 , 命令会新建一个目录叫做.deploy用于存放克隆的代码。</p>
<p>然后会在.deploy文件夹下生成一个 <strong>你的名字.github.io</strong> 的文件夹用于存放文件</p>
</li>
<li><p>接着在 Hexo <strong>根目录</strong>下创建一个 .txt 文件 , 把下面的命令复制进去</p>
</li>
<li><p>注意 ：<strong>你的GitHub名字</strong>是什么就<strong>把你的名字全部改到下面</strong> , 细心点（下面加粗的部分就是待修改的地方）</p>
<p>hexo generate</p>
<p>cp -R public/<em> .deploy/<em>*jacman</em></em>.github.io</p>
<p>cd .deploy/<strong>jacman</strong>.github.io</p>
<p>git add .</p>
<p>git commit -m “update”</p>
<p>git push origin master</p>
</li>
<li><p>将这个 <strong>.txt 文件的后缀改成 .sh</strong> , 它就变成了脚本文件 , 我们就将文件改成 <strong>deploy.sh</strong> 吧！意思就是部署</p>
</li>
<li><p>从此以后需要部署本地博客到 GitHub , 直接把脚本拖入到终端运行即可。</p>
</li>
</ol>
<p>该部分需要注意的事项：</p>
<ol>
<li>脚本拖入终端运行时一定要切换到 Hexo 目录下</li>
<li>运行如显示 Permission denied 说明没有权限，此时需要对脚本进行赋予权限的操作：在终端输入chmod 777，接着拖入脚本，再按回车，权限赋予成功后再把脚本拖入终端运行即可（运行脚本一定要切换到 Hexo目录下）。</li>
</ol>
<h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h3><p>搭建博客过程中会踩到许多坑，其中很多问题都是由于没有切换到 Hexo 目录下造成的。若能在终端上切换到正确的目录下进行操作，搭建博客的过程也会顺利不少。</p>
]]></content>
      
        <categories>
            
            <category> Hexo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
